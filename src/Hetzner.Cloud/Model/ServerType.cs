// <auto-generated>
/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.22.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization.Metadata;
using Hetzner.Cloud.Client;

namespace Hetzner.Cloud.Model
{
    /// <summary>
    /// ServerType
    /// </summary>
    public partial class ServerType : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ServerType" /> class.
        /// </summary>
        /// <param name="architecture">architecture</param>
        /// <param name="cores">Number of cpu cores a Server of this type will have</param>
        /// <param name="cpuType">Type of cpu</param>
        /// <param name="description">Description of the Server type</param>
        /// <param name="disk">Disk size a Server of this type will have in GB</param>
        /// <param name="id">ID of the Server type</param>
        /// <param name="memory">Memory a Server of this type will have in GB</param>
        /// <param name="name">Unique identifier of the Server type</param>
        /// <param name="prices">Price per [Location](#locations).</param>
        /// <param name="storageType">Type of Server boot drive. Local has higher speed. Network has better availability.</param>
        /// <param name="deprecated">This field is deprecated. Use the deprecation object instead</param>
        /// <param name="deprecation">deprecation</param>
        [JsonConstructor]
        public ServerType(Architecture architecture, int cores, CpuTypeEnum cpuType, string description, decimal disk, long id, decimal memory, string name, List<PricePerTime> prices, StorageTypeEnum storageType, bool? deprecated = default, Option<DeprecationInfo?> deprecation = default)
        {
            Architecture = architecture;
            Cores = cores;
            CpuType = cpuType;
            Description = description;
            Disk = disk;
            Id = id;
            Memory = memory;
            Name = name;
            Prices = prices;
            StorageType = storageType;
            Deprecated = deprecated;
            DeprecationOption = deprecation;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets Architecture
        /// </summary>
        [JsonPropertyName("architecture")]
        public Architecture Architecture { get; set; }

        /// <summary>
        /// Type of cpu
        /// </summary>
        /// <value>Type of cpu</value>
        public enum CpuTypeEnum
        {
            /// <summary>
            /// Enum Dedicated for value: dedicated
            /// </summary>
            Dedicated = 1,

            /// <summary>
            /// Enum Shared for value: shared
            /// </summary>
            Shared = 2
        }

        /// <summary>
        /// Returns a <see cref="CpuTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static CpuTypeEnum CpuTypeEnumFromString(string value)
        {
            if (value.Equals("dedicated"))
                return CpuTypeEnum.Dedicated;

            if (value.Equals("shared"))
                return CpuTypeEnum.Shared;

            throw new NotImplementedException($"Could not convert value to type CpuTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="CpuTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static CpuTypeEnum? CpuTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("dedicated"))
                return CpuTypeEnum.Dedicated;

            if (value.Equals("shared"))
                return CpuTypeEnum.Shared;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="CpuTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string CpuTypeEnumToJsonValue(CpuTypeEnum value)
        {
            if (value == CpuTypeEnum.Dedicated)
                return "dedicated";

            if (value == CpuTypeEnum.Shared)
                return "shared";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Type of cpu
        /// </summary>
        /// <value>Type of cpu</value>
        /* <example>shared</example> */
        [JsonPropertyName("cpu_type")]
        public CpuTypeEnum CpuType { get; set; }

        /// <summary>
        /// Type of Server boot drive. Local has higher speed. Network has better availability.
        /// </summary>
        /// <value>Type of Server boot drive. Local has higher speed. Network has better availability.</value>
        public enum StorageTypeEnum
        {
            /// <summary>
            /// Enum Local for value: local
            /// </summary>
            Local = 1,

            /// <summary>
            /// Enum Network for value: network
            /// </summary>
            Network = 2
        }

        /// <summary>
        /// Returns a <see cref="StorageTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static StorageTypeEnum StorageTypeEnumFromString(string value)
        {
            if (value.Equals("local"))
                return StorageTypeEnum.Local;

            if (value.Equals("network"))
                return StorageTypeEnum.Network;

            throw new NotImplementedException($"Could not convert value to type StorageTypeEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="StorageTypeEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static StorageTypeEnum? StorageTypeEnumFromStringOrDefault(string value)
        {
            if (value.Equals("local"))
                return StorageTypeEnum.Local;

            if (value.Equals("network"))
                return StorageTypeEnum.Network;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="StorageTypeEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string StorageTypeEnumToJsonValue(StorageTypeEnum value)
        {
            if (value == StorageTypeEnum.Local)
                return "local";

            if (value == StorageTypeEnum.Network)
                return "network";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Type of Server boot drive. Local has higher speed. Network has better availability.
        /// </summary>
        /// <value>Type of Server boot drive. Local has higher speed. Network has better availability.</value>
        [JsonPropertyName("storage_type")]
        public StorageTypeEnum StorageType { get; set; }

        /// <summary>
        /// Number of cpu cores a Server of this type will have
        /// </summary>
        /// <value>Number of cpu cores a Server of this type will have</value>
        /* <example>2</example> */
        [JsonPropertyName("cores")]
        public int Cores { get; set; }

        /// <summary>
        /// Description of the Server type
        /// </summary>
        /// <value>Description of the Server type</value>
        /* <example>CPX11</example> */
        [JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Disk size a Server of this type will have in GB
        /// </summary>
        /// <value>Disk size a Server of this type will have in GB</value>
        /* <example>40</example> */
        [JsonPropertyName("disk")]
        public decimal Disk { get; set; }

        /// <summary>
        /// ID of the Server type
        /// </summary>
        /// <value>ID of the Server type</value>
        /* <example>1</example> */
        [JsonPropertyName("id")]
        public long Id { get; set; }

        /// <summary>
        /// Memory a Server of this type will have in GB
        /// </summary>
        /// <value>Memory a Server of this type will have in GB</value>
        /* <example>2</example> */
        [JsonPropertyName("memory")]
        public decimal Memory { get; set; }

        /// <summary>
        /// Unique identifier of the Server type
        /// </summary>
        /// <value>Unique identifier of the Server type</value>
        /* <example>cpx11</example> */
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Price per [Location](#locations).
        /// </summary>
        /// <value>Price per [Location](#locations).</value>
        [JsonPropertyName("prices")]
        public List<PricePerTime> Prices { get; set; }

        /// <summary>
        /// This field is deprecated. Use the deprecation object instead
        /// </summary>
        /// <value>This field is deprecated. Use the deprecation object instead</value>
        /* <example>false</example> */
        [JsonPropertyName("deprecated")]
        public bool? Deprecated { get; set; }

        /// <summary>
        /// Used to track the state of Deprecation
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DeprecationInfo?> DeprecationOption { get; private set; }

        /// <summary>
        /// Gets or Sets Deprecation
        /// </summary>
        [JsonPropertyName("deprecation")]
        public DeprecationInfo? Deprecation { get { return this.DeprecationOption; } set { this.DeprecationOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class ServerType {\n");
            sb.Append("  Architecture: ").Append(Architecture).Append("\n");
            sb.Append("  Cores: ").Append(Cores).Append("\n");
            sb.Append("  CpuType: ").Append(CpuType).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  Disk: ").Append(Disk).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  Memory: ").Append(Memory).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Prices: ").Append(Prices).Append("\n");
            sb.Append("  StorageType: ").Append(StorageType).Append("\n");
            sb.Append("  Deprecated: ").Append(Deprecated).Append("\n");
            sb.Append("  Deprecation: ").Append(Deprecation).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Id (long) maximum
            if (this.Id > (long)9007199254740991)
            {
                yield return new ValidationResult("Invalid value for Id, must be a value less than or equal to 9007199254740991.", new [] { "Id" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="ServerType" />
    /// </summary>
    public class ServerTypeJsonConverter : JsonConverter<ServerType>
    {
        /// <summary>
        /// Deserializes json to <see cref="ServerType" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override ServerType Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Architecture?> architecture = default;
            Option<int?> cores = default;
            Option<ServerType.CpuTypeEnum?> cpuType = default;
            Option<string?> description = default;
            Option<decimal?> disk = default;
            Option<long?> id = default;
            Option<decimal?> memory = default;
            Option<string?> name = default;
            Option<List<PricePerTime>?> prices = default;
            Option<ServerType.StorageTypeEnum?> storageType = default;
            Option<bool?> deprecated = default;
            Option<DeprecationInfo?> deprecation = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "architecture":
                            string? architectureRawValue = utf8JsonReader.GetString();
                            if (architectureRawValue != null)
                                architecture = new Option<Architecture?>(ArchitectureValueConverter.FromStringOrDefault(architectureRawValue));
                            break;
                        case "cores":
                            cores = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "cpu_type":
                            string? cpuTypeRawValue = utf8JsonReader.GetString();
                            if (cpuTypeRawValue != null)
                                cpuType = new Option<ServerType.CpuTypeEnum?>(ServerType.CpuTypeEnumFromStringOrDefault(cpuTypeRawValue));
                            break;
                        case "description":
                            description = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "disk":
                            disk = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "id":
                            id = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "memory":
                            memory = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "name":
                            name = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "prices":
                            prices = new Option<List<PricePerTime>?>(JsonSerializer.Deserialize<List<PricePerTime>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "storage_type":
                            string? storageTypeRawValue = utf8JsonReader.GetString();
                            if (storageTypeRawValue != null)
                                storageType = new Option<ServerType.StorageTypeEnum?>(ServerType.StorageTypeEnumFromStringOrDefault(storageTypeRawValue));
                            break;
                        case "deprecated":
                            deprecated = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "deprecation":
                            deprecation = new Option<DeprecationInfo?>(JsonSerializer.Deserialize<DeprecationInfo>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!architecture.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(architecture));

            if (!cores.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(cores));

            if (!cpuType.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(cpuType));

            if (!description.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(description));

            if (!disk.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(disk));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(id));

            if (!memory.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(memory));

            if (!name.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(name));

            if (!prices.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(prices));

            if (!storageType.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(storageType));

            if (!deprecated.IsSet)
                throw new ArgumentException("Property is required for class ServerType.", nameof(deprecated));

            if (architecture.IsSet && architecture.Value == null)
                throw new ArgumentNullException(nameof(architecture), "Property is not nullable for class ServerType.");

            if (cores.IsSet && cores.Value == null)
                throw new ArgumentNullException(nameof(cores), "Property is not nullable for class ServerType.");

            if (cpuType.IsSet && cpuType.Value == null)
                throw new ArgumentNullException(nameof(cpuType), "Property is not nullable for class ServerType.");

            if (description.IsSet && description.Value == null)
                throw new ArgumentNullException(nameof(description), "Property is not nullable for class ServerType.");

            if (disk.IsSet && disk.Value == null)
                throw new ArgumentNullException(nameof(disk), "Property is not nullable for class ServerType.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class ServerType.");

            if (memory.IsSet && memory.Value == null)
                throw new ArgumentNullException(nameof(memory), "Property is not nullable for class ServerType.");

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name), "Property is not nullable for class ServerType.");

            if (prices.IsSet && prices.Value == null)
                throw new ArgumentNullException(nameof(prices), "Property is not nullable for class ServerType.");

            if (storageType.IsSet && storageType.Value == null)
                throw new ArgumentNullException(nameof(storageType), "Property is not nullable for class ServerType.");

            return new ServerType(architecture.Value!.Value!, cores.Value!.Value!, cpuType.Value!.Value!, description.Value!, disk.Value!.Value!, id.Value!.Value!, memory.Value!.Value!, name.Value!, prices.Value!, storageType.Value!.Value!, deprecated.Value!, deprecation);
        }

        /// <summary>
        /// Serializes a <see cref="ServerType" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="serverType"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, ServerType serverType, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, serverType, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="ServerType" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="serverType"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, ServerType serverType, JsonSerializerOptions jsonSerializerOptions)
        {
            if (serverType.Description == null)
                throw new ArgumentNullException(nameof(serverType.Description), "Property is required for class ServerType.");

            if (serverType.Name == null)
                throw new ArgumentNullException(nameof(serverType.Name), "Property is required for class ServerType.");

            if (serverType.Prices == null)
                throw new ArgumentNullException(nameof(serverType.Prices), "Property is required for class ServerType.");

            var architectureRawValue = ArchitectureValueConverter.ToJsonValue(serverType.Architecture);
            writer.WriteString("architecture", architectureRawValue);

            writer.WriteNumber("cores", serverType.Cores);

            var cpuTypeRawValue = ServerType.CpuTypeEnumToJsonValue(serverType.CpuType);
            writer.WriteString("cpu_type", cpuTypeRawValue);
            writer.WriteString("description", serverType.Description);

            writer.WriteNumber("disk", serverType.Disk);

            writer.WriteNumber("id", serverType.Id);

            writer.WriteNumber("memory", serverType.Memory);

            writer.WriteString("name", serverType.Name);

            writer.WritePropertyName("prices");
            JsonSerializer.Serialize(writer, serverType.Prices, jsonSerializerOptions);
            var storageTypeRawValue = ServerType.StorageTypeEnumToJsonValue(serverType.StorageType);
            writer.WriteString("storage_type", storageTypeRawValue);
            if (serverType.Deprecated != null)
                writer.WriteBoolean("deprecated", serverType.Deprecated.Value);
            else
                writer.WriteNull("deprecated");

            if (serverType.DeprecationOption.IsSet)
                if (serverType.DeprecationOption.Value != null)
                {
                    writer.WritePropertyName("deprecation");
                    JsonSerializer.Serialize(writer, serverType.Deprecation, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("deprecation");
        }
    }

    /// <summary>
    /// The ServerTypeSerializationContext
    /// </summary>
    [JsonSourceGenerationOptions(WriteIndented = true, GenerationMode = JsonSourceGenerationMode.Metadata | JsonSourceGenerationMode.Serialization)]
    [JsonSerializable(typeof(ServerType))]
    public partial class ServerTypeSerializationContext : JsonSerializerContext { }
}
