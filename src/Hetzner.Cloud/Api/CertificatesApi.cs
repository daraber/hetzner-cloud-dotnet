// <auto-generated>
/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.22.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Hetzner.Cloud.Client;
using Hetzner.Cloud.Model;
using System.Diagnostics.CodeAnalysis;

namespace Hetzner.Cloud.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    internal interface ICertificatesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        CertificatesApiEvents Events { get; }

        /// <summary>
        /// Create a Certificate
        /// </summary>
        /// <remarks>
        /// Creates a new Certificate.  The default type **uploaded** allows for uploading your existing &#x60;certificate&#x60; and &#x60;private_key&#x60; in PEM format. You have to monitor its expiration date and handle renewal yourself.  In contrast, type **managed** requests a new Certificate from *Let&#39;s Encrypt* for the specified &#x60;domain_names&#x60;. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.  For type &#x60;managed&#x60; Certificates the &#x60;action&#x60; key of the response contains the Action that allows for tracking the issuance process. For type &#x60;uploaded&#x60; Certificates the &#x60;action&#x60; is always null. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCertificateApiResponse"/>&gt;</returns>
        Task<ICreateCertificateApiResponse> CreateCertificateAsync(Option<CreateCertificateRequest> createCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Certificate
        /// </summary>
        /// <remarks>
        /// Creates a new Certificate.  The default type **uploaded** allows for uploading your existing &#x60;certificate&#x60; and &#x60;private_key&#x60; in PEM format. You have to monitor its expiration date and handle renewal yourself.  In contrast, type **managed** requests a new Certificate from *Let&#39;s Encrypt* for the specified &#x60;domain_names&#x60;. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.  For type &#x60;managed&#x60; Certificates the &#x60;action&#x60; key of the response contains the Action that allows for tracking the issuance process. For type &#x60;uploaded&#x60; Certificates the &#x60;action&#x60; is always null. 
        /// </remarks>
        /// <param name="createCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCertificateApiResponse"/>?&gt;</returns>
        Task<ICreateCertificateApiResponse?> CreateCertificateOrDefaultAsync(Option<CreateCertificateRequest> createCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Certificate
        /// </summary>
        /// <remarks>
        /// Deletes a Certificate.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCertificateApiResponse"/>&gt;</returns>
        Task<IDeleteCertificateApiResponse> DeleteCertificateAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Certificate
        /// </summary>
        /// <remarks>
        /// Deletes a Certificate.
        /// </remarks>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCertificateApiResponse"/>?&gt;</returns>
        Task<IDeleteCertificateApiResponse?> DeleteCertificateOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Certificate
        /// </summary>
        /// <remarks>
        /// Returns a specific Action for a Certificate. Only type &#x60;managed&#x60; Certificates have Actions.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForCertificateApiResponse"/>&gt;</returns>
        Task<IGetActionForCertificateApiResponse> GetActionForCertificateAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Certificate
        /// </summary>
        /// <remarks>
        /// Returns a specific Action for a Certificate. Only type &#x60;managed&#x60; Certificates have Actions.
        /// </remarks>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForCertificateApiResponse"/>?&gt;</returns>
        Task<IGetActionForCertificateApiResponse?> GetActionForCertificateOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Certificate
        /// </summary>
        /// <remarks>
        /// Gets a specific Certificate object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateApiResponse"/>&gt;</returns>
        Task<IGetCertificateApiResponse> GetCertificateAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Certificate
        /// </summary>
        /// <remarks>
        /// Gets a specific Certificate object.
        /// </remarks>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateApiResponse"/>?&gt;</returns>
        Task<IGetCertificateApiResponse?> GetCertificateOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateActionApiResponse"/>&gt;</returns>
        Task<IGetCertificateActionApiResponse> GetCertificateActionAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object.
        /// </remarks>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateActionApiResponse"/>?&gt;</returns>
        Task<IGetCertificateActionApiResponse?> GetCertificateActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Certificate
        /// </summary>
        /// <remarks>
        /// Returns all Action objects for a Certificate. You can sort the results by using the &#x60;sort&#x60; URI parameter, and filter them with the &#x60;status&#x60; parameter.  Only type &#x60;managed&#x60; Certificates can have Actions. For type &#x60;uploaded&#x60; Certificates the &#x60;actions&#x60; key will always contain an empty array. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForCertificateApiResponse"/>&gt;</returns>
        Task<IListActionsForCertificateApiResponse> ListActionsForCertificateAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Certificate
        /// </summary>
        /// <remarks>
        /// Returns all Action objects for a Certificate. You can sort the results by using the &#x60;sort&#x60; URI parameter, and filter them with the &#x60;status&#x60; parameter.  Only type &#x60;managed&#x60; Certificates can have Actions. For type &#x60;uploaded&#x60; Certificates the &#x60;actions&#x60; key will always contain an empty array. 
        /// </remarks>
        /// <param name="id">ID of the Certificate</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForCertificateApiResponse"/>?&gt;</returns>
        Task<IListActionsForCertificateApiResponse?> ListActionsForCertificateOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificateActionsApiResponse"/>&gt;</returns>
        Task<IListCertificateActionsApiResponse> ListCertificateActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </remarks>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificateActionsApiResponse"/>?&gt;</returns>
        Task<IListCertificateActionsApiResponse?> ListCertificateActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Certificates
        /// </summary>
        /// <remarks>
        /// Returns all Certificate objects.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="type">Can be used multiple times. The response will only contain Certificates matching the type. (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificatesApiResponse"/>&gt;</returns>
        Task<IListCertificatesApiResponse> ListCertificatesAsync(Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<string> type = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Certificates
        /// </summary>
        /// <remarks>
        /// Returns all Certificate objects.
        /// </remarks>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="type">Can be used multiple times. The response will only contain Certificates matching the type. (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificatesApiResponse"/>?&gt;</returns>
        Task<IListCertificatesApiResponse?> ListCertificatesOrDefaultAsync(Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<string> type = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Certificate
        /// </summary>
        /// <remarks>
        /// Updates the Certificate properties.  Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.  Note: if the Certificate object changes during the request, the response will be a “conflict” error. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="replaceCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceCertificateApiResponse"/>&gt;</returns>
        Task<IReplaceCertificateApiResponse> ReplaceCertificateAsync(long id, Option<ReplaceCertificateRequest> replaceCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Certificate
        /// </summary>
        /// <remarks>
        /// Updates the Certificate properties.  Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.  Note: if the Certificate object changes during the request, the response will be a “conflict” error. 
        /// </remarks>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="replaceCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceCertificateApiResponse"/>?&gt;</returns>
        Task<IReplaceCertificateApiResponse?> ReplaceCertificateOrDefaultAsync(long id, Option<ReplaceCertificateRequest> replaceCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retry Issuance or Renewal
        /// </summary>
        /// <remarks>
        /// Retry a failed Certificate issuance or renewal.  Only applicable if the type of the Certificate is &#x60;managed&#x60; and the issuance or renewal status is &#x60;failed&#x60;.  #### Call specific error codes  | Code                                                    | Description                                                               | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;caa_record_does_not_allow_ca&#x60;                          | CAA record does not allow certificate authority                           | | &#x60;ca_dns_validation_failed&#x60;                              | Certificate Authority: DNS validation failed                              | | &#x60;ca_too_many_authorizations_failed_recently&#x60;            | Certificate Authority: Too many authorizations failed recently            | | &#x60;ca_too_many_certificates_issued_for_registered_domain&#x60; | Certificate Authority: Too many certificates issued for registered domain | | &#x60;ca_too_many_duplicate_certificates&#x60;                    | Certificate Authority: Too many duplicate certificates                    | | &#x60;could_not_verify_domain_delegated_to_zone&#x60;             | Could not verify domain delegated to zone                                 | | &#x60;dns_zone_not_found&#x60;                                    | DNS zone not found                                                        | | &#x60;dns_zone_is_secondary_zone&#x60;                            | DNS zone is a secondary zone                                              | 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRetryIssuanceOrRenewalApiResponse"/>&gt;</returns>
        Task<IRetryIssuanceOrRenewalApiResponse> RetryIssuanceOrRenewalAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retry Issuance or Renewal
        /// </summary>
        /// <remarks>
        /// Retry a failed Certificate issuance or renewal.  Only applicable if the type of the Certificate is &#x60;managed&#x60; and the issuance or renewal status is &#x60;failed&#x60;.  #### Call specific error codes  | Code                                                    | Description                                                               | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;caa_record_does_not_allow_ca&#x60;                          | CAA record does not allow certificate authority                           | | &#x60;ca_dns_validation_failed&#x60;                              | Certificate Authority: DNS validation failed                              | | &#x60;ca_too_many_authorizations_failed_recently&#x60;            | Certificate Authority: Too many authorizations failed recently            | | &#x60;ca_too_many_certificates_issued_for_registered_domain&#x60; | Certificate Authority: Too many certificates issued for registered domain | | &#x60;ca_too_many_duplicate_certificates&#x60;                    | Certificate Authority: Too many duplicate certificates                    | | &#x60;could_not_verify_domain_delegated_to_zone&#x60;             | Could not verify domain delegated to zone                                 | | &#x60;dns_zone_not_found&#x60;                                    | DNS zone not found                                                        | | &#x60;dns_zone_is_secondary_zone&#x60;                            | DNS zone is a secondary zone                                              | 
        /// </remarks>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRetryIssuanceOrRenewalApiResponse"/>?&gt;</returns>
        Task<IRetryIssuanceOrRenewalApiResponse?> RetryIssuanceOrRenewalOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="ICreateCertificateApiResponse"/>
    /// </summary>
    internal interface ICreateCertificateApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.CreateCertificateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteCertificateApiResponse"/>
    /// </summary>
    internal interface IDeleteCertificateApiResponse : Hetzner.Cloud.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IGetActionForCertificateApiResponse"/>
    /// </summary>
    internal interface IGetActionForCertificateApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionForCertificateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetCertificateApiResponse"/>
    /// </summary>
    internal interface IGetCertificateApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetCertificateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetCertificateActionApiResponse"/>
    /// </summary>
    internal interface IGetCertificateActionApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListActionsForCertificateApiResponse"/>
    /// </summary>
    internal interface IListActionsForCertificateApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsForCertificateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListCertificateActionsApiResponse"/>
    /// </summary>
    internal interface IListCertificateActionsApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListCertificatesApiResponse"/>
    /// </summary>
    internal interface IListCertificatesApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListCertificatesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IReplaceCertificateApiResponse"/>
    /// </summary>
    internal interface IReplaceCertificateApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ReplaceCertificateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRetryIssuanceOrRenewalApiResponse"/>
    /// </summary>
    internal interface IRetryIssuanceOrRenewalApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.RetryIssuanceOrRenewalResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    internal class CertificatesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateCertificate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateCertificate;

        internal void ExecuteOnCreateCertificate(CertificatesApi.CreateCertificateApiResponse apiResponse)
        {
            OnCreateCertificate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateCertificate(Exception exception)
        {
            OnErrorCreateCertificate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteCertificate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteCertificate;

        internal void ExecuteOnDeleteCertificate(CertificatesApi.DeleteCertificateApiResponse apiResponse)
        {
            OnDeleteCertificate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteCertificate(Exception exception)
        {
            OnErrorDeleteCertificate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetActionForCertificate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetActionForCertificate;

        internal void ExecuteOnGetActionForCertificate(CertificatesApi.GetActionForCertificateApiResponse apiResponse)
        {
            OnGetActionForCertificate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetActionForCertificate(Exception exception)
        {
            OnErrorGetActionForCertificate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCertificate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCertificate;

        internal void ExecuteOnGetCertificate(CertificatesApi.GetCertificateApiResponse apiResponse)
        {
            OnGetCertificate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCertificate(Exception exception)
        {
            OnErrorGetCertificate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetCertificateAction;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetCertificateAction;

        internal void ExecuteOnGetCertificateAction(CertificatesApi.GetCertificateActionApiResponse apiResponse)
        {
            OnGetCertificateAction?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetCertificateAction(Exception exception)
        {
            OnErrorGetCertificateAction?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListActionsForCertificate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListActionsForCertificate;

        internal void ExecuteOnListActionsForCertificate(CertificatesApi.ListActionsForCertificateApiResponse apiResponse)
        {
            OnListActionsForCertificate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListActionsForCertificate(Exception exception)
        {
            OnErrorListActionsForCertificate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListCertificateActions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListCertificateActions;

        internal void ExecuteOnListCertificateActions(CertificatesApi.ListCertificateActionsApiResponse apiResponse)
        {
            OnListCertificateActions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListCertificateActions(Exception exception)
        {
            OnErrorListCertificateActions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListCertificates;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListCertificates;

        internal void ExecuteOnListCertificates(CertificatesApi.ListCertificatesApiResponse apiResponse)
        {
            OnListCertificates?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListCertificates(Exception exception)
        {
            OnErrorListCertificates?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnReplaceCertificate;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorReplaceCertificate;

        internal void ExecuteOnReplaceCertificate(CertificatesApi.ReplaceCertificateApiResponse apiResponse)
        {
            OnReplaceCertificate?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReplaceCertificate(Exception exception)
        {
            OnErrorReplaceCertificate?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRetryIssuanceOrRenewal;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRetryIssuanceOrRenewal;

        internal void ExecuteOnRetryIssuanceOrRenewal(CertificatesApi.RetryIssuanceOrRenewalApiResponse apiResponse)
        {
            OnRetryIssuanceOrRenewal?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRetryIssuanceOrRenewal(Exception exception)
        {
            OnErrorRetryIssuanceOrRenewal?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    internal sealed partial class CertificatesApi : ICertificatesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<CertificatesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public CertificatesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="CertificatesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public CertificatesApi(ILogger<CertificatesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, CertificatesApiEvents certificatesApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<CertificatesApi>();
            HttpClient = httpClient;
            Events = certificatesApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatCreateCertificate(Option<CreateCertificateRequest> createCertificateRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createCertificateRequest"></param>
        /// <returns></returns>
        private void ValidateCreateCertificate(Option<CreateCertificateRequest> createCertificateRequest)
        {
            if (createCertificateRequest.IsSet && createCertificateRequest.Value == null)
                throw new ArgumentNullException(nameof(createCertificateRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createCertificateRequest"></param>
        private void AfterCreateCertificateDefaultImplementation(ICreateCertificateApiResponse apiResponseLocalVar, Option<CreateCertificateRequest> createCertificateRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateCertificate(ref suppressDefaultLog, apiResponseLocalVar, createCertificateRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createCertificateRequest"></param>
        partial void AfterCreateCertificate(ref bool suppressDefaultLog, ICreateCertificateApiResponse apiResponseLocalVar, Option<CreateCertificateRequest> createCertificateRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createCertificateRequest"></param>
        private void OnErrorCreateCertificateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateCertificateRequest> createCertificateRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateCertificate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createCertificateRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createCertificateRequest"></param>
        partial void OnErrorCreateCertificate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateCertificateRequest> createCertificateRequest);

        /// <summary>
        /// Create a Certificate Creates a new Certificate.  The default type **uploaded** allows for uploading your existing &#x60;certificate&#x60; and &#x60;private_key&#x60; in PEM format. You have to monitor its expiration date and handle renewal yourself.  In contrast, type **managed** requests a new Certificate from *Let&#39;s Encrypt* for the specified &#x60;domain_names&#x60;. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.  For type &#x60;managed&#x60; Certificates the &#x60;action&#x60; key of the response contains the Action that allows for tracking the issuance process. For type &#x60;uploaded&#x60; Certificates the &#x60;action&#x60; is always null. 
        /// </summary>
        /// <param name="createCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCertificateApiResponse"/>&gt;</returns>
        public async Task<ICreateCertificateApiResponse?> CreateCertificateOrDefaultAsync(Option<CreateCertificateRequest> createCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateCertificateAsync(createCertificateRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Certificate Creates a new Certificate.  The default type **uploaded** allows for uploading your existing &#x60;certificate&#x60; and &#x60;private_key&#x60; in PEM format. You have to monitor its expiration date and handle renewal yourself.  In contrast, type **managed** requests a new Certificate from *Let&#39;s Encrypt* for the specified &#x60;domain_names&#x60;. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.  For type &#x60;managed&#x60; Certificates the &#x60;action&#x60; key of the response contains the Action that allows for tracking the issuance process. For type &#x60;uploaded&#x60; Certificates the &#x60;action&#x60; is always null. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateCertificateApiResponse"/>&gt;</returns>
        public async Task<ICreateCertificateApiResponse> CreateCertificateAsync(Option<CreateCertificateRequest> createCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateCertificate(createCertificateRequest);

                FormatCreateCertificate(createCertificateRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates");

                    if (createCertificateRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (createCertificateRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createCertificateRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateCertificateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateCertificateApiResponse>();

                        CreateCertificateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateCertificateDefaultImplementation(apiResponseLocalVar, createCertificateRequest);

                        Events.ExecuteOnCreateCertificate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateCertificateDefaultImplementation(e, "/certificates", uriBuilderLocalVar.Path, createCertificateRequest);
                Events.ExecuteOnErrorCreateCertificate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateCertificateApiResponse"/>
        /// </summary>
        internal partial class CreateCertificateApiResponse : Hetzner.Cloud.Client.ApiResponse, ICreateCertificateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateCertificateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateCertificateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateCertificateApiResponse(ILogger<CreateCertificateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.CreateCertificateResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.CreateCertificateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.CreateCertificateResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteCertificate(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteCertificateDefaultImplementation(IDeleteCertificateApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteCertificate(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteCertificate(ref bool suppressDefaultLog, IDeleteCertificateApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteCertificateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteCertificate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteCertificate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Delete a Certificate Deletes a Certificate.
        /// </summary>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCertificateApiResponse"/>&gt;</returns>
        public async Task<IDeleteCertificateApiResponse?> DeleteCertificateOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteCertificateAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a Certificate Deletes a Certificate.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteCertificateApiResponse"/>&gt;</returns>
        public async Task<IDeleteCertificateApiResponse> DeleteCertificateAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteCertificate(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteCertificateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteCertificateApiResponse>();

                        DeleteCertificateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteCertificateDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteCertificate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteCertificateDefaultImplementation(e, "/certificates/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteCertificate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteCertificateApiResponse"/>
        /// </summary>
        internal partial class DeleteCertificateApiResponse : Hetzner.Cloud.Client.ApiResponse, IDeleteCertificateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteCertificateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteCertificateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteCertificateApiResponse(ILogger<DeleteCertificateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetActionForCertificate(ref long id, ref long actionId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void AfterGetActionForCertificateDefaultImplementation(IGetActionForCertificateApiResponse apiResponseLocalVar, long id, long actionId)
        {
            bool suppressDefaultLog = false;
            AfterGetActionForCertificate(ref suppressDefaultLog, apiResponseLocalVar, id, actionId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void AfterGetActionForCertificate(ref bool suppressDefaultLog, IGetActionForCertificateApiResponse apiResponseLocalVar, long id, long actionId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void OnErrorGetActionForCertificateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetActionForCertificate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, actionId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void OnErrorGetActionForCertificate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId);

        /// <summary>
        /// Get an Action for a Certificate Returns a specific Action for a Certificate. Only type &#x60;managed&#x60; Certificates have Actions.
        /// </summary>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForCertificateApiResponse"/>&gt;</returns>
        public async Task<IGetActionForCertificateApiResponse?> GetActionForCertificateOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetActionForCertificateAsync(id, actionId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action for a Certificate Returns a specific Action for a Certificate. Only type &#x60;managed&#x60; Certificates have Actions.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForCertificateApiResponse"/>&gt;</returns>
        public async Task<IGetActionForCertificateApiResponse> GetActionForCertificateAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetActionForCertificate(ref id, ref actionId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/{id}/actions/{action_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/{id}/actions/{action_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baction_id%7D", Uri.EscapeDataString(actionId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetActionForCertificateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetActionForCertificateApiResponse>();

                        GetActionForCertificateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/{id}/actions/{action_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetActionForCertificateDefaultImplementation(apiResponseLocalVar, id, actionId);

                        Events.ExecuteOnGetActionForCertificate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetActionForCertificateDefaultImplementation(e, "/certificates/{id}/actions/{action_id}", uriBuilderLocalVar.Path, id, actionId);
                Events.ExecuteOnErrorGetActionForCertificate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetActionForCertificateApiResponse"/>
        /// </summary>
        internal partial class GetActionForCertificateApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetActionForCertificateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetActionForCertificateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetActionForCertificateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetActionForCertificateApiResponse(ILogger<GetActionForCertificateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionForCertificateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionForCertificateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionForCertificateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCertificate(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetCertificateDefaultImplementation(IGetCertificateApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetCertificate(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetCertificate(ref bool suppressDefaultLog, IGetCertificateApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetCertificateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCertificate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetCertificate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get a Certificate Gets a specific Certificate object.
        /// </summary>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateApiResponse"/>&gt;</returns>
        public async Task<IGetCertificateApiResponse?> GetCertificateOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCertificateAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a Certificate Gets a specific Certificate object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateApiResponse"/>&gt;</returns>
        public async Task<IGetCertificateApiResponse> GetCertificateAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetCertificate(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCertificateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCertificateApiResponse>();

                        GetCertificateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCertificateDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetCertificate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCertificateDefaultImplementation(e, "/certificates/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetCertificate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCertificateApiResponse"/>
        /// </summary>
        internal partial class GetCertificateApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetCertificateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCertificateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCertificateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCertificateApiResponse(ILogger<GetCertificateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetCertificateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetCertificateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetCertificateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetCertificateAction(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetCertificateActionDefaultImplementation(IGetCertificateActionApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetCertificateAction(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetCertificateAction(ref bool suppressDefaultLog, IGetCertificateActionApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetCertificateActionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetCertificateAction(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetCertificateAction(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get an Action Returns a specific Action object.
        /// </summary>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateActionApiResponse"/>&gt;</returns>
        public async Task<IGetCertificateActionApiResponse?> GetCertificateActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetCertificateActionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action Returns a specific Action object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetCertificateActionApiResponse"/>&gt;</returns>
        public async Task<IGetCertificateActionApiResponse> GetCertificateActionAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetCertificateAction(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/actions/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/actions/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetCertificateActionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetCertificateActionApiResponse>();

                        GetCertificateActionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/actions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetCertificateActionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetCertificateAction(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetCertificateActionDefaultImplementation(e, "/certificates/actions/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetCertificateAction(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetCertificateActionApiResponse"/>
        /// </summary>
        internal partial class GetCertificateActionApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetCertificateActionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetCertificateActionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetCertificateActionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetCertificateActionApiResponse(ILogger<GetCertificateActionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListActionsForCertificate(ref long id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListActionsForCertificate(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListActionsForCertificateDefaultImplementation(IListActionsForCertificateApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListActionsForCertificate(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListActionsForCertificate(ref bool suppressDefaultLog, IListActionsForCertificateApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListActionsForCertificateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListActionsForCertificate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListActionsForCertificate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions for a Certificate Returns all Action objects for a Certificate. You can sort the results by using the &#x60;sort&#x60; URI parameter, and filter them with the &#x60;status&#x60; parameter.  Only type &#x60;managed&#x60; Certificates can have Actions. For type &#x60;uploaded&#x60; Certificates the &#x60;actions&#x60; key will always contain an empty array. 
        /// </summary>
        /// <param name="id">ID of the Certificate</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForCertificateApiResponse"/>&gt;</returns>
        public async Task<IListActionsForCertificateApiResponse?> ListActionsForCertificateOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListActionsForCertificateAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions for a Certificate Returns all Action objects for a Certificate. You can sort the results by using the &#x60;sort&#x60; URI parameter, and filter them with the &#x60;status&#x60; parameter.  Only type &#x60;managed&#x60; Certificates can have Actions. For type &#x60;uploaded&#x60; Certificates the &#x60;actions&#x60; key will always contain an empty array. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForCertificateApiResponse"/>&gt;</returns>
        public async Task<IListActionsForCertificateApiResponse> ListActionsForCertificateAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListActionsForCertificate(sort, status);

                FormatListActionsForCertificate(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/{id}/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/{id}/actions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListActionsForCertificateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListActionsForCertificateApiResponse>();

                        ListActionsForCertificateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/{id}/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListActionsForCertificateDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListActionsForCertificate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListActionsForCertificateDefaultImplementation(e, "/certificates/{id}/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListActionsForCertificate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListActionsForCertificateApiResponse"/>
        /// </summary>
        internal partial class ListActionsForCertificateApiResponse : Hetzner.Cloud.Client.ApiResponse, IListActionsForCertificateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListActionsForCertificateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListActionsForCertificateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListActionsForCertificateApiResponse(ILogger<ListActionsForCertificateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsForCertificateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsForCertificateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsForCertificateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListCertificateActions(ref Option<long> id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListCertificateActions(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListCertificateActionsDefaultImplementation(IListCertificateActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListCertificateActions(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListCertificateActions(ref bool suppressDefaultLog, IListCertificateActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListCertificateActionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListCertificateActions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListCertificateActions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </summary>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificateActionsApiResponse"/>&gt;</returns>
        public async Task<IListCertificateActionsApiResponse?> ListCertificateActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListCertificateActionsAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificateActionsApiResponse"/>&gt;</returns>
        public async Task<IListCertificateActionsApiResponse> ListCertificateActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListCertificateActions(sort, status);

                FormatListCertificateActions(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/actions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListCertificateActionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListCertificateActionsApiResponse>();

                        ListCertificateActionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListCertificateActionsDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListCertificateActions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListCertificateActionsDefaultImplementation(e, "/certificates/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListCertificateActions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListCertificateActionsApiResponse"/>
        /// </summary>
        internal partial class ListCertificateActionsApiResponse : Hetzner.Cloud.Client.ApiResponse, IListCertificateActionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListCertificateActionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListCertificateActionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListCertificateActionsApiResponse(ILogger<ListCertificateActionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListCertificates(ref Option<string> sort, ref Option<string> name, ref Option<string> labelSelector, ref Option<string> type, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="type"></param>
        /// <returns></returns>
        private void ValidateListCertificates(Option<string> sort, Option<string> name, Option<string> labelSelector, Option<string> type)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (labelSelector.IsSet && labelSelector.Value == null)
                throw new ArgumentNullException(nameof(labelSelector));

            if (type.IsSet && type.Value == null)
                throw new ArgumentNullException(nameof(type));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="type"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListCertificatesDefaultImplementation(IListCertificatesApiResponse apiResponseLocalVar, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<string> type, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListCertificates(ref suppressDefaultLog, apiResponseLocalVar, sort, name, labelSelector, type, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="type"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListCertificates(ref bool suppressDefaultLog, IListCertificatesApiResponse apiResponseLocalVar, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<string> type, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="type"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListCertificatesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<string> type, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListCertificates(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sort, name, labelSelector, type, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="type"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListCertificates(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<string> type, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Certificates Returns all Certificate objects.
        /// </summary>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="type">Can be used multiple times. The response will only contain Certificates matching the type. (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificatesApiResponse"/>&gt;</returns>
        public async Task<IListCertificatesApiResponse?> ListCertificatesOrDefaultAsync(Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<string> type = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListCertificatesAsync(sort, name, labelSelector, type, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Certificates Returns all Certificate objects.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="type">Can be used multiple times. The response will only contain Certificates matching the type. (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListCertificatesApiResponse"/>&gt;</returns>
        public async Task<IListCertificatesApiResponse> ListCertificatesAsync(Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<string> type = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListCertificates(sort, name, labelSelector, type);

                FormatListCertificates(ref sort, ref name, ref labelSelector, ref type, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (labelSelector.IsSet)
                        parseQueryStringLocalVar["label_selector"] = ClientUtils.ParameterToString(labelSelector.Value);

                    if (type.IsSet)
                        parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListCertificatesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListCertificatesApiResponse>();

                        ListCertificatesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListCertificatesDefaultImplementation(apiResponseLocalVar, sort, name, labelSelector, type, page, perPage);

                        Events.ExecuteOnListCertificates(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListCertificatesDefaultImplementation(e, "/certificates", uriBuilderLocalVar.Path, sort, name, labelSelector, type, page, perPage);
                Events.ExecuteOnErrorListCertificates(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListCertificatesApiResponse"/>
        /// </summary>
        internal partial class ListCertificatesApiResponse : Hetzner.Cloud.Client.ApiResponse, IListCertificatesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListCertificatesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListCertificatesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListCertificatesApiResponse(ILogger<ListCertificatesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListCertificatesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListCertificatesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListCertificatesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReplaceCertificate(ref long id, Option<ReplaceCertificateRequest> replaceCertificateRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="replaceCertificateRequest"></param>
        /// <returns></returns>
        private void ValidateReplaceCertificate(Option<ReplaceCertificateRequest> replaceCertificateRequest)
        {
            if (replaceCertificateRequest.IsSet && replaceCertificateRequest.Value == null)
                throw new ArgumentNullException(nameof(replaceCertificateRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceCertificateRequest"></param>
        private void AfterReplaceCertificateDefaultImplementation(IReplaceCertificateApiResponse apiResponseLocalVar, long id, Option<ReplaceCertificateRequest> replaceCertificateRequest)
        {
            bool suppressDefaultLog = false;
            AfterReplaceCertificate(ref suppressDefaultLog, apiResponseLocalVar, id, replaceCertificateRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceCertificateRequest"></param>
        partial void AfterReplaceCertificate(ref bool suppressDefaultLog, IReplaceCertificateApiResponse apiResponseLocalVar, long id, Option<ReplaceCertificateRequest> replaceCertificateRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceCertificateRequest"></param>
        private void OnErrorReplaceCertificateDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceCertificateRequest> replaceCertificateRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorReplaceCertificate(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, replaceCertificateRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceCertificateRequest"></param>
        partial void OnErrorReplaceCertificate(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceCertificateRequest> replaceCertificateRequest);

        /// <summary>
        /// Update a Certificate Updates the Certificate properties.  Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.  Note: if the Certificate object changes during the request, the response will be a “conflict” error. 
        /// </summary>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="replaceCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceCertificateApiResponse"/>&gt;</returns>
        public async Task<IReplaceCertificateApiResponse?> ReplaceCertificateOrDefaultAsync(long id, Option<ReplaceCertificateRequest> replaceCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReplaceCertificateAsync(id, replaceCertificateRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update a Certificate Updates the Certificate properties.  Note that when updating labels, the Certificate’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.  Note: if the Certificate object changes during the request, the response will be a “conflict” error. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="replaceCertificateRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceCertificateApiResponse"/>&gt;</returns>
        public async Task<IReplaceCertificateApiResponse> ReplaceCertificateAsync(long id, Option<ReplaceCertificateRequest> replaceCertificateRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateReplaceCertificate(replaceCertificateRequest);

                FormatReplaceCertificate(ref id, replaceCertificateRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (replaceCertificateRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (replaceCertificateRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(replaceCertificateRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ReplaceCertificateApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReplaceCertificateApiResponse>();

                        ReplaceCertificateApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReplaceCertificateDefaultImplementation(apiResponseLocalVar, id, replaceCertificateRequest);

                        Events.ExecuteOnReplaceCertificate(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReplaceCertificateDefaultImplementation(e, "/certificates/{id}", uriBuilderLocalVar.Path, id, replaceCertificateRequest);
                Events.ExecuteOnErrorReplaceCertificate(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReplaceCertificateApiResponse"/>
        /// </summary>
        internal partial class ReplaceCertificateApiResponse : Hetzner.Cloud.Client.ApiResponse, IReplaceCertificateApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReplaceCertificateApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReplaceCertificateApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReplaceCertificateApiResponse(ILogger<ReplaceCertificateApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ReplaceCertificateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ReplaceCertificateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ReplaceCertificateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRetryIssuanceOrRenewal(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterRetryIssuanceOrRenewalDefaultImplementation(IRetryIssuanceOrRenewalApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterRetryIssuanceOrRenewal(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterRetryIssuanceOrRenewal(ref bool suppressDefaultLog, IRetryIssuanceOrRenewalApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorRetryIssuanceOrRenewalDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRetryIssuanceOrRenewal(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorRetryIssuanceOrRenewal(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Retry Issuance or Renewal Retry a failed Certificate issuance or renewal.  Only applicable if the type of the Certificate is &#x60;managed&#x60; and the issuance or renewal status is &#x60;failed&#x60;.  #### Call specific error codes  | Code                                                    | Description                                                               | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;caa_record_does_not_allow_ca&#x60;                          | CAA record does not allow certificate authority                           | | &#x60;ca_dns_validation_failed&#x60;                              | Certificate Authority: DNS validation failed                              | | &#x60;ca_too_many_authorizations_failed_recently&#x60;            | Certificate Authority: Too many authorizations failed recently            | | &#x60;ca_too_many_certificates_issued_for_registered_domain&#x60; | Certificate Authority: Too many certificates issued for registered domain | | &#x60;ca_too_many_duplicate_certificates&#x60;                    | Certificate Authority: Too many duplicate certificates                    | | &#x60;could_not_verify_domain_delegated_to_zone&#x60;             | Could not verify domain delegated to zone                                 | | &#x60;dns_zone_not_found&#x60;                                    | DNS zone not found                                                        | | &#x60;dns_zone_is_secondary_zone&#x60;                            | DNS zone is a secondary zone                                              | 
        /// </summary>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRetryIssuanceOrRenewalApiResponse"/>&gt;</returns>
        public async Task<IRetryIssuanceOrRenewalApiResponse?> RetryIssuanceOrRenewalOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RetryIssuanceOrRenewalAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retry Issuance or Renewal Retry a failed Certificate issuance or renewal.  Only applicable if the type of the Certificate is &#x60;managed&#x60; and the issuance or renewal status is &#x60;failed&#x60;.  #### Call specific error codes  | Code                                                    | Description                                                               | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;caa_record_does_not_allow_ca&#x60;                          | CAA record does not allow certificate authority                           | | &#x60;ca_dns_validation_failed&#x60;                              | Certificate Authority: DNS validation failed                              | | &#x60;ca_too_many_authorizations_failed_recently&#x60;            | Certificate Authority: Too many authorizations failed recently            | | &#x60;ca_too_many_certificates_issued_for_registered_domain&#x60; | Certificate Authority: Too many certificates issued for registered domain | | &#x60;ca_too_many_duplicate_certificates&#x60;                    | Certificate Authority: Too many duplicate certificates                    | | &#x60;could_not_verify_domain_delegated_to_zone&#x60;             | Could not verify domain delegated to zone                                 | | &#x60;dns_zone_not_found&#x60;                                    | DNS zone not found                                                        | | &#x60;dns_zone_is_secondary_zone&#x60;                            | DNS zone is a secondary zone                                              | 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Certificate.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRetryIssuanceOrRenewalApiResponse"/>&gt;</returns>
        public async Task<IRetryIssuanceOrRenewalApiResponse> RetryIssuanceOrRenewalAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRetryIssuanceOrRenewal(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/certificates/{id}/actions/retry"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/certificates/{id}/actions/retry");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RetryIssuanceOrRenewalApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RetryIssuanceOrRenewalApiResponse>();

                        RetryIssuanceOrRenewalApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/certificates/{id}/actions/retry", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRetryIssuanceOrRenewalDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnRetryIssuanceOrRenewal(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRetryIssuanceOrRenewalDefaultImplementation(e, "/certificates/{id}/actions/retry", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorRetryIssuanceOrRenewal(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RetryIssuanceOrRenewalApiResponse"/>
        /// </summary>
        internal partial class RetryIssuanceOrRenewalApiResponse : Hetzner.Cloud.Client.ApiResponse, IRetryIssuanceOrRenewalApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RetryIssuanceOrRenewalApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RetryIssuanceOrRenewalApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RetryIssuanceOrRenewalApiResponse(ILogger<RetryIssuanceOrRenewalApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.RetryIssuanceOrRenewalResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.RetryIssuanceOrRenewalResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.RetryIssuanceOrRenewalResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
