// <auto-generated>
/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.22.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Hetzner.Cloud.Client;
using Hetzner.Cloud.Model;
using System.Diagnostics.CodeAnalysis;

namespace Hetzner.Cloud.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IServersApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ServersApiEvents Events { get; }

        /// <summary>
        /// Add a Server to a Placement Group
        /// </summary>
        /// <remarks>
        /// Adds a Server to a Placement Group.  Server must be powered off for this command to succeed.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="addServerToPlacementGroupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddServerToPlacementGroupApiResponse"/>&gt;</returns>
        Task<IAddServerToPlacementGroupApiResponse> AddServerToPlacementGroupAsync(long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Add a Server to a Placement Group
        /// </summary>
        /// <remarks>
        /// Adds a Server to a Placement Group.  Server must be powered off for this command to succeed.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="addServerToPlacementGroupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddServerToPlacementGroupApiResponse"/>?&gt;</returns>
        Task<IAddServerToPlacementGroupApiResponse?> AddServerToPlacementGroupOrDefaultAsync(long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Attach an ISO to a Server
        /// </summary>
        /// <remarks>
        /// Attaches an ISO to a Server. The Server will immediately see it as a new disk. An already attached ISO will automatically be detached before the new ISO is attached.  Servers with attached ISOs have a modified boot order: They will try to boot from the ISO first before falling back to hard disk. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachIsoToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachIsoToServerApiResponse"/>&gt;</returns>
        Task<IAttachIsoToServerApiResponse> AttachIsoToServerAsync(long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Attach an ISO to a Server
        /// </summary>
        /// <remarks>
        /// Attaches an ISO to a Server. The Server will immediately see it as a new disk. An already attached ISO will automatically be detached before the new ISO is attached.  Servers with attached ISOs have a modified boot order: They will try to boot from the ISO first before falling back to hard disk. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachIsoToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachIsoToServerApiResponse"/>?&gt;</returns>
        Task<IAttachIsoToServerApiResponse?> AttachIsoToServerOrDefaultAsync(long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Attach a Server to a Network
        /// </summary>
        /// <remarks>
        /// Attaches a Server to a network. This will complement the fixed public Server interface by adding an additional ethernet interface to the Server which is connected to the specified network.  The Server will get an IP auto assigned from a subnet of type &#x60;server&#x60; in the same &#x60;network_zone&#x60;.  Using the &#x60;alias_ips&#x60; attribute you can also define one or more additional IPs to the Servers. Please note that you will have to configure these IPs by hand on your Server since only the primary IP will be given out by DHCP.  **Call specific error codes**  | Code                             | Description                                                           | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;server_already_attached&#x60;        | The server is already attached to the network                         | | &#x60;ip_not_available&#x60;               | The provided Network IP is not available                              | | &#x60;no_subnet_available&#x60;            | No Subnet or IP is available for the Server within the network        | | &#x60;networks_overlap&#x60;               | The network IP range overlaps with one of the server networks         | 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachServerToNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachServerToNetworkApiResponse"/>&gt;</returns>
        Task<IAttachServerToNetworkApiResponse> AttachServerToNetworkAsync(long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Attach a Server to a Network
        /// </summary>
        /// <remarks>
        /// Attaches a Server to a network. This will complement the fixed public Server interface by adding an additional ethernet interface to the Server which is connected to the specified network.  The Server will get an IP auto assigned from a subnet of type &#x60;server&#x60; in the same &#x60;network_zone&#x60;.  Using the &#x60;alias_ips&#x60; attribute you can also define one or more additional IPs to the Servers. Please note that you will have to configure these IPs by hand on your Server since only the primary IP will be given out by DHCP.  **Call specific error codes**  | Code                             | Description                                                           | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;server_already_attached&#x60;        | The server is already attached to the network                         | | &#x60;ip_not_available&#x60;               | The provided Network IP is not available                              | | &#x60;no_subnet_available&#x60;            | No Subnet or IP is available for the Server within the network        | | &#x60;networks_overlap&#x60;               | The network IP range overlaps with one of the server networks         | 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachServerToNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachServerToNetworkApiResponse"/>?&gt;</returns>
        Task<IAttachServerToNetworkApiResponse?> AttachServerToNetworkOrDefaultAsync(long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change alias IPs of a Network
        /// </summary>
        /// <remarks>
        /// Changes the alias IPs of an already attached Network. Note that the existing aliases for the specified Network will be replaced with these provided in the request body. So if you want to add an alias IP, you have to provide the existing ones from the Network plus the new alias IP in the request body.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeAliasIpsOfNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeAliasIpsOfNetworkApiResponse"/>&gt;</returns>
        Task<IChangeAliasIpsOfNetworkApiResponse> ChangeAliasIpsOfNetworkAsync(long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change alias IPs of a Network
        /// </summary>
        /// <remarks>
        /// Changes the alias IPs of an already attached Network. Note that the existing aliases for the specified Network will be replaced with these provided in the request body. So if you want to add an alias IP, you have to provide the existing ones from the Network plus the new alias IP in the request body.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeAliasIpsOfNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeAliasIpsOfNetworkApiResponse"/>?&gt;</returns>
        Task<IChangeAliasIpsOfNetworkApiResponse?> ChangeAliasIpsOfNetworkOrDefaultAsync(long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change reverse DNS entry for this Server
        /// </summary>
        /// <remarks>
        /// Changes the hostname that will appear when getting the hostname belonging to the primary IPs (IPv4 and IPv6) of this Server.  Floating IPs assigned to the Server are not affected by this. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeReverseDnsEntryForThisServerRequest">Select the IP address for which to change the DNS entry by passing &#x60;ip&#x60;. It can be either IPv4 or IPv6. The target hostname is set by passing &#x60;dns_ptr&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsEntryForThisServerApiResponse"/>&gt;</returns>
        Task<IChangeReverseDnsEntryForThisServerApiResponse> ChangeReverseDnsEntryForThisServerAsync(long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change reverse DNS entry for this Server
        /// </summary>
        /// <remarks>
        /// Changes the hostname that will appear when getting the hostname belonging to the primary IPs (IPv4 and IPv6) of this Server.  Floating IPs assigned to the Server are not affected by this. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeReverseDnsEntryForThisServerRequest">Select the IP address for which to change the DNS entry by passing &#x60;ip&#x60;. It can be either IPv4 or IPv6. The target hostname is set by passing &#x60;dns_ptr&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsEntryForThisServerApiResponse"/>?&gt;</returns>
        Task<IChangeReverseDnsEntryForThisServerApiResponse?> ChangeReverseDnsEntryForThisServerOrDefaultAsync(long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change Server Protection
        /// </summary>
        /// <remarks>
        /// Changes the protection configuration of the Server.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeServerProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeServerProtectionApiResponse"/>&gt;</returns>
        Task<IChangeServerProtectionApiResponse> ChangeServerProtectionAsync(long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change Server Protection
        /// </summary>
        /// <remarks>
        /// Changes the protection configuration of the Server.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeServerProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeServerProtectionApiResponse"/>?&gt;</returns>
        Task<IChangeServerProtectionApiResponse?> ChangeServerProtectionOrDefaultAsync(long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change the Type of a Server
        /// </summary>
        /// <remarks>
        /// Changes the type (Cores, RAM and disk sizes) of a Server.  Server must be powered off for this command to succeed.  This copies the content of its disk, and starts it again.  You can only migrate to Server types with the same &#x60;storage_type&#x60; and equal or bigger disks. Shrinking disks is not possible as it might destroy data.  If the disk gets upgraded, the Server type can not be downgraded any more. If you plan to downgrade the Server type, set &#x60;upgrade_disk&#x60; to &#x60;false&#x60;.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;invalid_server_type&#x60;         | The server type does not fit for the given server or is deprecated   | | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeTypeOfServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeTypeOfServerApiResponse"/>&gt;</returns>
        Task<IChangeTypeOfServerApiResponse> ChangeTypeOfServerAsync(long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change the Type of a Server
        /// </summary>
        /// <remarks>
        /// Changes the type (Cores, RAM and disk sizes) of a Server.  Server must be powered off for this command to succeed.  This copies the content of its disk, and starts it again.  You can only migrate to Server types with the same &#x60;storage_type&#x60; and equal or bigger disks. Shrinking disks is not possible as it might destroy data.  If the disk gets upgraded, the Server type can not be downgraded any more. If you plan to downgrade the Server type, set &#x60;upgrade_disk&#x60; to &#x60;false&#x60;.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;invalid_server_type&#x60;         | The server type does not fit for the given server or is deprecated   | | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeTypeOfServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeTypeOfServerApiResponse"/>?&gt;</returns>
        Task<IChangeTypeOfServerApiResponse?> ChangeTypeOfServerOrDefaultAsync(long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Image from a Server
        /// </summary>
        /// <remarks>
        /// Creates an Image (snapshot) from a Server by copying the contents of its disks. This creates a snapshot of the current state of the disk and copies it into an Image. If the Server is currently running you must make sure that its disk content is consistent. Otherwise, the created Image may not be readable.  To make sure disk content is consistent, we recommend to shut down the Server prior to creating an Image.  You can either create a &#x60;backup&#x60; Image that is bound to the Server and therefore will be deleted when the Server is deleted, or you can create a &#x60;snapshot&#x60; Image which is completely independent of the Server it was created from and will survive Server deletion. Backup Images are only available when the backup option is enabled for the Server. Snapshot Images are billed on a per GB basis. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="createImageFromServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateImageFromServerApiResponse"/>&gt;</returns>
        Task<ICreateImageFromServerApiResponse> CreateImageFromServerAsync(long id, Option<CreateImageFromServerRequest> createImageFromServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create Image from a Server
        /// </summary>
        /// <remarks>
        /// Creates an Image (snapshot) from a Server by copying the contents of its disks. This creates a snapshot of the current state of the disk and copies it into an Image. If the Server is currently running you must make sure that its disk content is consistent. Otherwise, the created Image may not be readable.  To make sure disk content is consistent, we recommend to shut down the Server prior to creating an Image.  You can either create a &#x60;backup&#x60; Image that is bound to the Server and therefore will be deleted when the Server is deleted, or you can create a &#x60;snapshot&#x60; Image which is completely independent of the Server it was created from and will survive Server deletion. Backup Images are only available when the backup option is enabled for the Server. Snapshot Images are billed on a per GB basis. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="createImageFromServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateImageFromServerApiResponse"/>?&gt;</returns>
        Task<ICreateImageFromServerApiResponse?> CreateImageFromServerOrDefaultAsync(long id, Option<CreateImageFromServerRequest> createImageFromServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Server
        /// </summary>
        /// <remarks>
        /// Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createServerRequest">Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).  For &#x60;server_type&#x60; you can either use the ID as listed in &#x60;/server_types&#x60; or its name.  For &#x60;image&#x60; you can either use the ID as listed in &#x60;/images&#x60; or its name.  If you want to create the Server in a Location, you must set &#x60;location&#x60; to the ID or name as listed in &#x60;/locations&#x60;. This is the recommended way. You can be even more specific by setting &#x60;datacenter&#x60; to the ID or name as listed in &#x60;/datacenters&#x60;. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.  Some properties like &#x60;start_after_create&#x60; or &#x60;automount&#x60; will trigger Actions after the Server is created. Those Actions are listed in the &#x60;next_actions&#x60; field in the response.  For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in &#x60;ssh_keys&#x60;. If you do not specify any &#x60;ssh_keys&#x60; we will generate a root password for you and return it in the response.  Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.  #### Call specific error codes  | Code                             | Description                                                | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;placement_error&#x60;                | An error during the placement occurred                     | | &#x60;primary_ip_assigned&#x60;            | The specified Primary IP is already assigned to a server   | | &#x60;primary_ip_datacenter_mismatch&#x60; | The specified Primary IP is in a different datacenter      | | &#x60;primary_ip_version_mismatch&#x60;    | The specified Primary IP has the wrong IP Version          |  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateServerApiResponse"/>&gt;</returns>
        Task<ICreateServerApiResponse> CreateServerAsync(Option<CreateServerRequest> createServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Server
        /// </summary>
        /// <remarks>
        /// Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation.
        /// </remarks>
        /// <param name="createServerRequest">Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).  For &#x60;server_type&#x60; you can either use the ID as listed in &#x60;/server_types&#x60; or its name.  For &#x60;image&#x60; you can either use the ID as listed in &#x60;/images&#x60; or its name.  If you want to create the Server in a Location, you must set &#x60;location&#x60; to the ID or name as listed in &#x60;/locations&#x60;. This is the recommended way. You can be even more specific by setting &#x60;datacenter&#x60; to the ID or name as listed in &#x60;/datacenters&#x60;. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.  Some properties like &#x60;start_after_create&#x60; or &#x60;automount&#x60; will trigger Actions after the Server is created. Those Actions are listed in the &#x60;next_actions&#x60; field in the response.  For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in &#x60;ssh_keys&#x60;. If you do not specify any &#x60;ssh_keys&#x60; we will generate a root password for you and return it in the response.  Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.  #### Call specific error codes  | Code                             | Description                                                | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;placement_error&#x60;                | An error during the placement occurred                     | | &#x60;primary_ip_assigned&#x60;            | The specified Primary IP is already assigned to a server   | | &#x60;primary_ip_datacenter_mismatch&#x60; | The specified Primary IP is in a different datacenter      | | &#x60;primary_ip_version_mismatch&#x60;    | The specified Primary IP has the wrong IP Version          |  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateServerApiResponse"/>?&gt;</returns>
        Task<ICreateServerApiResponse?> CreateServerOrDefaultAsync(Option<CreateServerRequest> createServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Server
        /// </summary>
        /// <remarks>
        /// Deletes a Server. This immediately removes the Server from your account, and it is no longer accessible. Any resources attached to the server (like Volumes, Primary IPs, Floating IPs, Firewalls, Placement Groups) are detached while the server is deleted. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteServerApiResponse"/>&gt;</returns>
        Task<IDeleteServerApiResponse> DeleteServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Server
        /// </summary>
        /// <remarks>
        /// Deletes a Server. This immediately removes the Server from your account, and it is no longer accessible. Any resources attached to the server (like Volumes, Primary IPs, Floating IPs, Firewalls, Placement Groups) are detached while the server is deleted. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteServerApiResponse"/>?&gt;</returns>
        Task<IDeleteServerApiResponse?> DeleteServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detach an ISO from a Server
        /// </summary>
        /// <remarks>
        /// Detaches an ISO from a Server. In case no ISO Image is attached to the Server, the status of the returned Action is immediately set to &#x60;success&#x60;
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachIsoFromServerApiResponse"/>&gt;</returns>
        Task<IDetachIsoFromServerApiResponse> DetachIsoFromServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detach an ISO from a Server
        /// </summary>
        /// <remarks>
        /// Detaches an ISO from a Server. In case no ISO Image is attached to the Server, the status of the returned Action is immediately set to &#x60;success&#x60;
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachIsoFromServerApiResponse"/>?&gt;</returns>
        Task<IDetachIsoFromServerApiResponse?> DetachIsoFromServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detach a Server from a Network
        /// </summary>
        /// <remarks>
        /// Detaches a Server from a network. The interface for this network will vanish.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="detachServerFromNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachServerFromNetworkApiResponse"/>&gt;</returns>
        Task<IDetachServerFromNetworkApiResponse> DetachServerFromNetworkAsync(long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detach a Server from a Network
        /// </summary>
        /// <remarks>
        /// Detaches a Server from a network. The interface for this network will vanish.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="detachServerFromNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachServerFromNetworkApiResponse"/>?&gt;</returns>
        Task<IDetachServerFromNetworkApiResponse?> DetachServerFromNetworkOrDefaultAsync(long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Disable Backups for a Server
        /// </summary>
        /// <remarks>
        /// Disables the automatic backup option and deletes all existing Backups for a Server. No more additional charges for backups will be made.  Caution: This immediately removes all existing backups for the Server! 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableBackupsForServerApiResponse"/>&gt;</returns>
        Task<IDisableBackupsForServerApiResponse> DisableBackupsForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Disable Backups for a Server
        /// </summary>
        /// <remarks>
        /// Disables the automatic backup option and deletes all existing Backups for a Server. No more additional charges for backups will be made.  Caution: This immediately removes all existing backups for the Server! 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableBackupsForServerApiResponse"/>?&gt;</returns>
        Task<IDisableBackupsForServerApiResponse?> DisableBackupsForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Disable Rescue Mode for a Server
        /// </summary>
        /// <remarks>
        /// Disables the Hetzner Rescue System for a Server. This makes a Server start from its disks on next reboot.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Disabling rescue mode will not reboot your Server — you will have to do this yourself. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableRescueModeForServerApiResponse"/>&gt;</returns>
        Task<IDisableRescueModeForServerApiResponse> DisableRescueModeForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Disable Rescue Mode for a Server
        /// </summary>
        /// <remarks>
        /// Disables the Hetzner Rescue System for a Server. This makes a Server start from its disks on next reboot.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Disabling rescue mode will not reboot your Server — you will have to do this yourself. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableRescueModeForServerApiResponse"/>?&gt;</returns>
        Task<IDisableRescueModeForServerApiResponse?> DisableRescueModeForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Enable and Configure Backups for a Server
        /// </summary>
        /// <remarks>
        /// Enables and configures the automatic daily backup option for the Server. Enabling automatic backups will increase the price of the Server by 20%. In return, you will get seven slots where Images of type backup can be stored.  Backups are automatically created daily. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableAndConfigureBackupsForServerApiResponse"/>&gt;</returns>
        Task<IEnableAndConfigureBackupsForServerApiResponse> EnableAndConfigureBackupsForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Enable and Configure Backups for a Server
        /// </summary>
        /// <remarks>
        /// Enables and configures the automatic daily backup option for the Server. Enabling automatic backups will increase the price of the Server by 20%. In return, you will get seven slots where Images of type backup can be stored.  Backups are automatically created daily. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableAndConfigureBackupsForServerApiResponse"/>?&gt;</returns>
        Task<IEnableAndConfigureBackupsForServerApiResponse?> EnableAndConfigureBackupsForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Enable Rescue Mode for a Server
        /// </summary>
        /// <remarks>
        /// Enable the Hetzner Rescue System for this Server. The next time a Server with enabled rescue mode boots it will start a special minimal Linux distribution designed for repair and reinstall.  In case a Server cannot boot on its own you can use this to access a Server’s disks.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Enabling rescue mode will not [reboot](https://docs.hetzner.cloud/#server-actions-soft-reboot-a-server) your Server — you will have to do this yourself. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="enableRescueModeForServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableRescueModeForServerApiResponse"/>&gt;</returns>
        Task<IEnableRescueModeForServerApiResponse> EnableRescueModeForServerAsync(long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Enable Rescue Mode for a Server
        /// </summary>
        /// <remarks>
        /// Enable the Hetzner Rescue System for this Server. The next time a Server with enabled rescue mode boots it will start a special minimal Linux distribution designed for repair and reinstall.  In case a Server cannot boot on its own you can use this to access a Server’s disks.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Enabling rescue mode will not [reboot](https://docs.hetzner.cloud/#server-actions-soft-reboot-a-server) your Server — you will have to do this yourself. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="enableRescueModeForServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableRescueModeForServerApiResponse"/>?&gt;</returns>
        Task<IEnableRescueModeForServerApiResponse?> EnableRescueModeForServerOrDefaultAsync(long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Server
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object for a Server.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForServerApiResponse"/>&gt;</returns>
        Task<IGetActionForServerApiResponse> GetActionForServerAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Server
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object for a Server.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForServerApiResponse"/>?&gt;</returns>
        Task<IGetActionForServerApiResponse?> GetActionForServerOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Metrics for a Server
        /// </summary>
        /// <remarks>
        /// Get Metrics for specified Server.  You must specify the type of metric to get: cpu, disk or network. You can also specify more than one type by comma separation, e.g. cpu,disk.  Depending on the type you will get different time series data  | Type    | Timeseries              | Unit      | Description                                          | |- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | cpu     | cpu                     | percent   | Percent CPU usage                                    | | disk    | disk.0.iops.read        | iop/s     | Number of read IO operations per second              | |         | disk.0.iops.write       | iop/s     | Number of write IO operations per second             | |         | disk.0.bandwidth.read   | bytes/s   | Bytes read per second                                | |         | disk.0.bandwidth.write  | bytes/s   | Bytes written per second                             | | network | network.0.pps.in        | packets/s | Public Network interface packets per second received | |         | network.0.pps.out       | packets/s | Public Network interface packets per second sent     | |         | network.0.bandwidth.in  | bytes/s   | Public Network interface bytes/s received            | |         | network.0.bandwidth.out | bytes/s   | Public Network interface bytes/s sent                |  Metrics are available for the last 30 days only.  If you do not provide the step argument we will automatically adjust it so that a maximum of 200 samples are returned.  We limit the number of samples returned to a maximum of 500 and will adjust the step parameter accordingly. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="type">Type of metrics to get</param>
        /// <param name="start">Start of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="end">End of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="step">Resolution of results in seconds (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMetricsForServerApiResponse"/>&gt;</returns>
        Task<IGetMetricsForServerApiResponse> GetMetricsForServerAsync(long id, string type, string start, string end, Option<string> step = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get Metrics for a Server
        /// </summary>
        /// <remarks>
        /// Get Metrics for specified Server.  You must specify the type of metric to get: cpu, disk or network. You can also specify more than one type by comma separation, e.g. cpu,disk.  Depending on the type you will get different time series data  | Type    | Timeseries              | Unit      | Description                                          | |- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | cpu     | cpu                     | percent   | Percent CPU usage                                    | | disk    | disk.0.iops.read        | iop/s     | Number of read IO operations per second              | |         | disk.0.iops.write       | iop/s     | Number of write IO operations per second             | |         | disk.0.bandwidth.read   | bytes/s   | Bytes read per second                                | |         | disk.0.bandwidth.write  | bytes/s   | Bytes written per second                             | | network | network.0.pps.in        | packets/s | Public Network interface packets per second received | |         | network.0.pps.out       | packets/s | Public Network interface packets per second sent     | |         | network.0.bandwidth.in  | bytes/s   | Public Network interface bytes/s received            | |         | network.0.bandwidth.out | bytes/s   | Public Network interface bytes/s sent                |  Metrics are available for the last 30 days only.  If you do not provide the step argument we will automatically adjust it so that a maximum of 200 samples are returned.  We limit the number of samples returned to a maximum of 500 and will adjust the step parameter accordingly. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="type">Type of metrics to get</param>
        /// <param name="start">Start of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="end">End of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="step">Resolution of results in seconds (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMetricsForServerApiResponse"/>?&gt;</returns>
        Task<IGetMetricsForServerApiResponse?> GetMetricsForServerOrDefaultAsync(long id, string type, string start, string end, Option<string> step = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Server
        /// </summary>
        /// <remarks>
        /// Returns a specific Server object. The Server must exist inside the Project
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerApiResponse"/>&gt;</returns>
        Task<IGetServerApiResponse> GetServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Server
        /// </summary>
        /// <remarks>
        /// Returns a specific Server object. The Server must exist inside the Project
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerApiResponse"/>?&gt;</returns>
        Task<IGetServerApiResponse?> GetServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerActionApiResponse"/>&gt;</returns>
        Task<IGetServerActionApiResponse> GetServerActionAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object.
        /// </remarks>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerActionApiResponse"/>?&gt;</returns>
        Task<IGetServerActionApiResponse?> GetServerActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Server
        /// </summary>
        /// <remarks>
        /// Returns all Action objects for a Server. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForServerApiResponse"/>&gt;</returns>
        Task<IListActionsForServerApiResponse> ListActionsForServerAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Server
        /// </summary>
        /// <remarks>
        /// Returns all Action objects for a Server. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </remarks>
        /// <param name="id">ID of the Server</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForServerApiResponse"/>?&gt;</returns>
        Task<IListActionsForServerApiResponse?> ListActionsForServerOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServerActionsApiResponse"/>&gt;</returns>
        Task<IListServerActionsApiResponse> ListServerActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </remarks>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServerActionsApiResponse"/>?&gt;</returns>
        Task<IListServerActionsApiResponse?> ListServerActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Servers
        /// </summary>
        /// <remarks>
        /// Returns all existing Server objects
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Can be used multiple times. The response will only contain Server matching the status (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServersApiResponse"/>&gt;</returns>
        Task<IListServersApiResponse> ListServersAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Servers
        /// </summary>
        /// <remarks>
        /// Returns all existing Server objects
        /// </remarks>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Can be used multiple times. The response will only contain Server matching the status (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServersApiResponse"/>?&gt;</returns>
        Task<IListServersApiResponse?> ListServersOrDefaultAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Power off a Server
        /// </summary>
        /// <remarks>
        /// Cuts power to the Server. This forcefully stops it without giving the Server operating system time to gracefully stop. May lead to data loss, equivalent to pulling the power cord. Power off should only be used when shutdown does not work.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOffServerApiResponse"/>&gt;</returns>
        Task<IPowerOffServerApiResponse> PowerOffServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Power off a Server
        /// </summary>
        /// <remarks>
        /// Cuts power to the Server. This forcefully stops it without giving the Server operating system time to gracefully stop. May lead to data loss, equivalent to pulling the power cord. Power off should only be used when shutdown does not work.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOffServerApiResponse"/>?&gt;</returns>
        Task<IPowerOffServerApiResponse?> PowerOffServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Power on a Server
        /// </summary>
        /// <remarks>
        /// Starts a Server by turning its power on.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOnServerApiResponse"/>&gt;</returns>
        Task<IPowerOnServerApiResponse> PowerOnServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Power on a Server
        /// </summary>
        /// <remarks>
        /// Starts a Server by turning its power on.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOnServerApiResponse"/>?&gt;</returns>
        Task<IPowerOnServerApiResponse?> PowerOnServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Rebuild a Server from an Image
        /// </summary>
        /// <remarks>
        /// Rebuilds a Server overwriting its disk with the content of an Image, thereby **destroying all data** on the target Server  The Image can either be one you have created earlier (&#x60;backup&#x60; or &#x60;snapshot&#x60; Image) or it can be a completely fresh &#x60;system&#x60; Image provided by us. You can get a list of all available Images with &#x60;GET /images&#x60;.  Your Server will automatically be powered off before the rebuild command executes. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="rebuildServerFromImageRequest">To select which Image to rebuild from you can either pass an ID or a name as the &#x60;image&#x60; argument. Passing a name only works for &#x60;system&#x60; Images since the other Image types do not have a name set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRebuildServerFromImageApiResponse"/>&gt;</returns>
        Task<IRebuildServerFromImageApiResponse> RebuildServerFromImageAsync(long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Rebuild a Server from an Image
        /// </summary>
        /// <remarks>
        /// Rebuilds a Server overwriting its disk with the content of an Image, thereby **destroying all data** on the target Server  The Image can either be one you have created earlier (&#x60;backup&#x60; or &#x60;snapshot&#x60; Image) or it can be a completely fresh &#x60;system&#x60; Image provided by us. You can get a list of all available Images with &#x60;GET /images&#x60;.  Your Server will automatically be powered off before the rebuild command executes. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="rebuildServerFromImageRequest">To select which Image to rebuild from you can either pass an ID or a name as the &#x60;image&#x60; argument. Passing a name only works for &#x60;system&#x60; Images since the other Image types do not have a name set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRebuildServerFromImageApiResponse"/>?&gt;</returns>
        Task<IRebuildServerFromImageApiResponse?> RebuildServerFromImageOrDefaultAsync(long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove from Placement Group
        /// </summary>
        /// <remarks>
        /// Removes a Server from a Placement Group. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveFromPlacementGroupApiResponse"/>&gt;</returns>
        Task<IRemoveFromPlacementGroupApiResponse> RemoveFromPlacementGroupAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Remove from Placement Group
        /// </summary>
        /// <remarks>
        /// Removes a Server from a Placement Group. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveFromPlacementGroupApiResponse"/>?&gt;</returns>
        Task<IRemoveFromPlacementGroupApiResponse?> RemoveFromPlacementGroupOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Server
        /// </summary>
        /// <remarks>
        /// Updates a Server. You can update a Server’s name and a Server’s labels. Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes). Also note that when updating labels, the Server’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="replaceServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceServerApiResponse"/>&gt;</returns>
        Task<IReplaceServerApiResponse> ReplaceServerAsync(long id, Option<ReplaceServerRequest> replaceServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Server
        /// </summary>
        /// <remarks>
        /// Updates a Server. You can update a Server’s name and a Server’s labels. Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes). Also note that when updating labels, the Server’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="replaceServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceServerApiResponse"/>?&gt;</returns>
        Task<IReplaceServerApiResponse?> ReplaceServerOrDefaultAsync(long id, Option<ReplaceServerRequest> replaceServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Request Console for a Server
        /// </summary>
        /// <remarks>
        /// Requests credentials for remote access via VNC over websocket to keyboard, monitor, and mouse for a Server. The provided URL is valid for 1 minute, after this period a new url needs to be created to connect to the Server. How long the connection is open after the initial connect is not subject to this timeout.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRequestConsoleForServerApiResponse"/>&gt;</returns>
        Task<IRequestConsoleForServerApiResponse> RequestConsoleForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Request Console for a Server
        /// </summary>
        /// <remarks>
        /// Requests credentials for remote access via VNC over websocket to keyboard, monitor, and mouse for a Server. The provided URL is valid for 1 minute, after this period a new url needs to be created to connect to the Server. How long the connection is open after the initial connect is not subject to this timeout.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRequestConsoleForServerApiResponse"/>?&gt;</returns>
        Task<IRequestConsoleForServerApiResponse?> RequestConsoleForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reset root Password of a Server
        /// </summary>
        /// <remarks>
        /// Resets the root password. Only works for Linux systems that are running the qemu guest agent. Server must be powered on (status &#x60;running&#x60;) in order for this operation to succeed.  This will generate a new password for this Server and return it.  If this does not succeed you can use the rescue system to netboot the Server and manually change your Server password by hand. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetRootPasswordOfServerApiResponse"/>&gt;</returns>
        Task<IResetRootPasswordOfServerApiResponse> ResetRootPasswordOfServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reset root Password of a Server
        /// </summary>
        /// <remarks>
        /// Resets the root password. Only works for Linux systems that are running the qemu guest agent. Server must be powered on (status &#x60;running&#x60;) in order for this operation to succeed.  This will generate a new password for this Server and return it.  If this does not succeed you can use the rescue system to netboot the Server and manually change your Server password by hand. 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetRootPasswordOfServerApiResponse"/>?&gt;</returns>
        Task<IResetRootPasswordOfServerApiResponse?> ResetRootPasswordOfServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reset a Server
        /// </summary>
        /// <remarks>
        /// Cuts power to a Server and starts it again. This forcefully stops it without giving the Server operating system time to gracefully stop. This may lead to data loss, it’s equivalent to pulling the power cord and plugging it in again. Reset should only be used when reboot does not work.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetServerApiResponse"/>&gt;</returns>
        Task<IResetServerApiResponse> ResetServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Reset a Server
        /// </summary>
        /// <remarks>
        /// Cuts power to a Server and starts it again. This forcefully stops it without giving the Server operating system time to gracefully stop. This may lead to data loss, it’s equivalent to pulling the power cord and plugging it in again. Reset should only be used when reboot does not work.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetServerApiResponse"/>?&gt;</returns>
        Task<IResetServerApiResponse?> ResetServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Shutdown a Server
        /// </summary>
        /// <remarks>
        /// Shuts down a Server gracefully by sending an ACPI shutdown request. The Server operating system must support ACPI and react to the request, otherwise the Server will not shut down. Please note that the &#x60;action&#x60; status in this case only reflects whether the action was sent to the server. It does not mean that the server actually shut down successfully. If you need to ensure that the server is off, use the &#x60;poweroff&#x60; action 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IShutdownServerApiResponse"/>&gt;</returns>
        Task<IShutdownServerApiResponse> ShutdownServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Shutdown a Server
        /// </summary>
        /// <remarks>
        /// Shuts down a Server gracefully by sending an ACPI shutdown request. The Server operating system must support ACPI and react to the request, otherwise the Server will not shut down. Please note that the &#x60;action&#x60; status in this case only reflects whether the action was sent to the server. It does not mean that the server actually shut down successfully. If you need to ensure that the server is off, use the &#x60;poweroff&#x60; action 
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IShutdownServerApiResponse"/>?&gt;</returns>
        Task<IShutdownServerApiResponse?> ShutdownServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Soft-reboot a Server
        /// </summary>
        /// <remarks>
        /// Reboots a Server gracefully by sending an ACPI request. The Server operating system must support ACPI and react to the request, otherwise the Server will not reboot.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISoftRebootServerApiResponse"/>&gt;</returns>
        Task<ISoftRebootServerApiResponse> SoftRebootServerAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Soft-reboot a Server
        /// </summary>
        /// <remarks>
        /// Reboots a Server gracefully by sending an ACPI request. The Server operating system must support ACPI and react to the request, otherwise the Server will not reboot.
        /// </remarks>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISoftRebootServerApiResponse"/>?&gt;</returns>
        Task<ISoftRebootServerApiResponse?> SoftRebootServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAddServerToPlacementGroupApiResponse"/>
    /// </summary>
    public interface IAddServerToPlacementGroupApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.AddServerToPlacementGroupResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IAttachIsoToServerApiResponse"/>
    /// </summary>
    public interface IAttachIsoToServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.AttachIsoToServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IAttachServerToNetworkApiResponse"/>
    /// </summary>
    public interface IAttachServerToNetworkApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.AttachServerToNetworkResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeAliasIpsOfNetworkApiResponse"/>
    /// </summary>
    public interface IChangeAliasIpsOfNetworkApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeAliasIpsOfNetworkResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeReverseDnsEntryForThisServerApiResponse"/>
    /// </summary>
    public interface IChangeReverseDnsEntryForThisServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeReverseDnsEntryForThisServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeServerProtectionApiResponse"/>
    /// </summary>
    public interface IChangeServerProtectionApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeServerProtectionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeTypeOfServerApiResponse"/>
    /// </summary>
    public interface IChangeTypeOfServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeTypeOfServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateImageFromServerApiResponse"/>
    /// </summary>
    public interface ICreateImageFromServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.CreateImageFromServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateServerApiResponse"/>
    /// </summary>
    public interface ICreateServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.CreateServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteServerApiResponse"/>
    /// </summary>
    public interface IDeleteServerApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.DeleteServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IDetachIsoFromServerApiResponse"/>
    /// </summary>
    public interface IDetachIsoFromServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.DetachIsoFromServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDetachServerFromNetworkApiResponse"/>
    /// </summary>
    public interface IDetachServerFromNetworkApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.DetachServerFromNetworkResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDisableBackupsForServerApiResponse"/>
    /// </summary>
    public interface IDisableBackupsForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.DisableBackupsForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDisableRescueModeForServerApiResponse"/>
    /// </summary>
    public interface IDisableRescueModeForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.DisableRescueModeForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IEnableAndConfigureBackupsForServerApiResponse"/>
    /// </summary>
    public interface IEnableAndConfigureBackupsForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.EnableAndConfigureBackupsForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IEnableRescueModeForServerApiResponse"/>
    /// </summary>
    public interface IEnableRescueModeForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.EnableRescueModeForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IGetActionForServerApiResponse"/>
    /// </summary>
    public interface IGetActionForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetMetricsForServerApiResponse"/>
    /// </summary>
    public interface IGetMetricsForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetMetricsForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetServerApiResponse"/>
    /// </summary>
    public interface IGetServerApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetServerActionApiResponse"/>
    /// </summary>
    public interface IGetServerActionApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListActionsForServerApiResponse"/>
    /// </summary>
    public interface IListActionsForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListServerActionsApiResponse"/>
    /// </summary>
    public interface IListServerActionsApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListServersApiResponse"/>
    /// </summary>
    public interface IListServersApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListServersResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IPowerOffServerApiResponse"/>
    /// </summary>
    public interface IPowerOffServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.PowerOffServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IPowerOnServerApiResponse"/>
    /// </summary>
    public interface IPowerOnServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.PowerOnServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IRebuildServerFromImageApiResponse"/>
    /// </summary>
    public interface IRebuildServerFromImageApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.RebuildServerFromImageResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IRemoveFromPlacementGroupApiResponse"/>
    /// </summary>
    public interface IRemoveFromPlacementGroupApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.RemoveFromPlacementGroupResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IReplaceServerApiResponse"/>
    /// </summary>
    public interface IReplaceServerApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ReplaceServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IRequestConsoleForServerApiResponse"/>
    /// </summary>
    public interface IRequestConsoleForServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.RequestConsoleForServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IResetRootPasswordOfServerApiResponse"/>
    /// </summary>
    public interface IResetRootPasswordOfServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ResetRootPasswordOfServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IResetServerApiResponse"/>
    /// </summary>
    public interface IResetServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ResetServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IShutdownServerApiResponse"/>
    /// </summary>
    public interface IShutdownServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ShutdownServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ISoftRebootServerApiResponse"/>
    /// </summary>
    public interface ISoftRebootServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.SoftRebootServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ServersApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAddServerToPlacementGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAddServerToPlacementGroup;

        internal void ExecuteOnAddServerToPlacementGroup(ServersApi.AddServerToPlacementGroupApiResponse apiResponse)
        {
            OnAddServerToPlacementGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAddServerToPlacementGroup(Exception exception)
        {
            OnErrorAddServerToPlacementGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAttachIsoToServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAttachIsoToServer;

        internal void ExecuteOnAttachIsoToServer(ServersApi.AttachIsoToServerApiResponse apiResponse)
        {
            OnAttachIsoToServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAttachIsoToServer(Exception exception)
        {
            OnErrorAttachIsoToServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAttachServerToNetwork;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAttachServerToNetwork;

        internal void ExecuteOnAttachServerToNetwork(ServersApi.AttachServerToNetworkApiResponse apiResponse)
        {
            OnAttachServerToNetwork?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAttachServerToNetwork(Exception exception)
        {
            OnErrorAttachServerToNetwork?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeAliasIpsOfNetwork;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeAliasIpsOfNetwork;

        internal void ExecuteOnChangeAliasIpsOfNetwork(ServersApi.ChangeAliasIpsOfNetworkApiResponse apiResponse)
        {
            OnChangeAliasIpsOfNetwork?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeAliasIpsOfNetwork(Exception exception)
        {
            OnErrorChangeAliasIpsOfNetwork?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeReverseDnsEntryForThisServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeReverseDnsEntryForThisServer;

        internal void ExecuteOnChangeReverseDnsEntryForThisServer(ServersApi.ChangeReverseDnsEntryForThisServerApiResponse apiResponse)
        {
            OnChangeReverseDnsEntryForThisServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeReverseDnsEntryForThisServer(Exception exception)
        {
            OnErrorChangeReverseDnsEntryForThisServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeServerProtection;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeServerProtection;

        internal void ExecuteOnChangeServerProtection(ServersApi.ChangeServerProtectionApiResponse apiResponse)
        {
            OnChangeServerProtection?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeServerProtection(Exception exception)
        {
            OnErrorChangeServerProtection?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeTypeOfServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeTypeOfServer;

        internal void ExecuteOnChangeTypeOfServer(ServersApi.ChangeTypeOfServerApiResponse apiResponse)
        {
            OnChangeTypeOfServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeTypeOfServer(Exception exception)
        {
            OnErrorChangeTypeOfServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateImageFromServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateImageFromServer;

        internal void ExecuteOnCreateImageFromServer(ServersApi.CreateImageFromServerApiResponse apiResponse)
        {
            OnCreateImageFromServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateImageFromServer(Exception exception)
        {
            OnErrorCreateImageFromServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateServer;

        internal void ExecuteOnCreateServer(ServersApi.CreateServerApiResponse apiResponse)
        {
            OnCreateServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateServer(Exception exception)
        {
            OnErrorCreateServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteServer;

        internal void ExecuteOnDeleteServer(ServersApi.DeleteServerApiResponse apiResponse)
        {
            OnDeleteServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteServer(Exception exception)
        {
            OnErrorDeleteServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDetachIsoFromServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDetachIsoFromServer;

        internal void ExecuteOnDetachIsoFromServer(ServersApi.DetachIsoFromServerApiResponse apiResponse)
        {
            OnDetachIsoFromServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDetachIsoFromServer(Exception exception)
        {
            OnErrorDetachIsoFromServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDetachServerFromNetwork;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDetachServerFromNetwork;

        internal void ExecuteOnDetachServerFromNetwork(ServersApi.DetachServerFromNetworkApiResponse apiResponse)
        {
            OnDetachServerFromNetwork?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDetachServerFromNetwork(Exception exception)
        {
            OnErrorDetachServerFromNetwork?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDisableBackupsForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDisableBackupsForServer;

        internal void ExecuteOnDisableBackupsForServer(ServersApi.DisableBackupsForServerApiResponse apiResponse)
        {
            OnDisableBackupsForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDisableBackupsForServer(Exception exception)
        {
            OnErrorDisableBackupsForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDisableRescueModeForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDisableRescueModeForServer;

        internal void ExecuteOnDisableRescueModeForServer(ServersApi.DisableRescueModeForServerApiResponse apiResponse)
        {
            OnDisableRescueModeForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDisableRescueModeForServer(Exception exception)
        {
            OnErrorDisableRescueModeForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEnableAndConfigureBackupsForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEnableAndConfigureBackupsForServer;

        internal void ExecuteOnEnableAndConfigureBackupsForServer(ServersApi.EnableAndConfigureBackupsForServerApiResponse apiResponse)
        {
            OnEnableAndConfigureBackupsForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEnableAndConfigureBackupsForServer(Exception exception)
        {
            OnErrorEnableAndConfigureBackupsForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEnableRescueModeForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEnableRescueModeForServer;

        internal void ExecuteOnEnableRescueModeForServer(ServersApi.EnableRescueModeForServerApiResponse apiResponse)
        {
            OnEnableRescueModeForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEnableRescueModeForServer(Exception exception)
        {
            OnErrorEnableRescueModeForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetActionForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetActionForServer;

        internal void ExecuteOnGetActionForServer(ServersApi.GetActionForServerApiResponse apiResponse)
        {
            OnGetActionForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetActionForServer(Exception exception)
        {
            OnErrorGetActionForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetMetricsForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetMetricsForServer;

        internal void ExecuteOnGetMetricsForServer(ServersApi.GetMetricsForServerApiResponse apiResponse)
        {
            OnGetMetricsForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetMetricsForServer(Exception exception)
        {
            OnErrorGetMetricsForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetServer;

        internal void ExecuteOnGetServer(ServersApi.GetServerApiResponse apiResponse)
        {
            OnGetServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetServer(Exception exception)
        {
            OnErrorGetServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetServerAction;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetServerAction;

        internal void ExecuteOnGetServerAction(ServersApi.GetServerActionApiResponse apiResponse)
        {
            OnGetServerAction?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetServerAction(Exception exception)
        {
            OnErrorGetServerAction?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListActionsForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListActionsForServer;

        internal void ExecuteOnListActionsForServer(ServersApi.ListActionsForServerApiResponse apiResponse)
        {
            OnListActionsForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListActionsForServer(Exception exception)
        {
            OnErrorListActionsForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListServerActions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListServerActions;

        internal void ExecuteOnListServerActions(ServersApi.ListServerActionsApiResponse apiResponse)
        {
            OnListServerActions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListServerActions(Exception exception)
        {
            OnErrorListServerActions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListServers;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListServers;

        internal void ExecuteOnListServers(ServersApi.ListServersApiResponse apiResponse)
        {
            OnListServers?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListServers(Exception exception)
        {
            OnErrorListServers?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPowerOffServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPowerOffServer;

        internal void ExecuteOnPowerOffServer(ServersApi.PowerOffServerApiResponse apiResponse)
        {
            OnPowerOffServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPowerOffServer(Exception exception)
        {
            OnErrorPowerOffServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPowerOnServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPowerOnServer;

        internal void ExecuteOnPowerOnServer(ServersApi.PowerOnServerApiResponse apiResponse)
        {
            OnPowerOnServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPowerOnServer(Exception exception)
        {
            OnErrorPowerOnServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRebuildServerFromImage;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRebuildServerFromImage;

        internal void ExecuteOnRebuildServerFromImage(ServersApi.RebuildServerFromImageApiResponse apiResponse)
        {
            OnRebuildServerFromImage?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRebuildServerFromImage(Exception exception)
        {
            OnErrorRebuildServerFromImage?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRemoveFromPlacementGroup;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRemoveFromPlacementGroup;

        internal void ExecuteOnRemoveFromPlacementGroup(ServersApi.RemoveFromPlacementGroupApiResponse apiResponse)
        {
            OnRemoveFromPlacementGroup?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRemoveFromPlacementGroup(Exception exception)
        {
            OnErrorRemoveFromPlacementGroup?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnReplaceServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorReplaceServer;

        internal void ExecuteOnReplaceServer(ServersApi.ReplaceServerApiResponse apiResponse)
        {
            OnReplaceServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReplaceServer(Exception exception)
        {
            OnErrorReplaceServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRequestConsoleForServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRequestConsoleForServer;

        internal void ExecuteOnRequestConsoleForServer(ServersApi.RequestConsoleForServerApiResponse apiResponse)
        {
            OnRequestConsoleForServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRequestConsoleForServer(Exception exception)
        {
            OnErrorRequestConsoleForServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnResetRootPasswordOfServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorResetRootPasswordOfServer;

        internal void ExecuteOnResetRootPasswordOfServer(ServersApi.ResetRootPasswordOfServerApiResponse apiResponse)
        {
            OnResetRootPasswordOfServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorResetRootPasswordOfServer(Exception exception)
        {
            OnErrorResetRootPasswordOfServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnResetServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorResetServer;

        internal void ExecuteOnResetServer(ServersApi.ResetServerApiResponse apiResponse)
        {
            OnResetServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorResetServer(Exception exception)
        {
            OnErrorResetServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnShutdownServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorShutdownServer;

        internal void ExecuteOnShutdownServer(ServersApi.ShutdownServerApiResponse apiResponse)
        {
            OnShutdownServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorShutdownServer(Exception exception)
        {
            OnErrorShutdownServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSoftRebootServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSoftRebootServer;

        internal void ExecuteOnSoftRebootServer(ServersApi.SoftRebootServerApiResponse apiResponse)
        {
            OnSoftRebootServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSoftRebootServer(Exception exception)
        {
            OnErrorSoftRebootServer?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ServersApi : IServersApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ServersApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ServersApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ServersApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ServersApi(ILogger<ServersApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ServersApiEvents serversApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ServersApi>();
            HttpClient = httpClient;
            Events = serversApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatAddServerToPlacementGroup(ref long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="addServerToPlacementGroupRequest"></param>
        /// <returns></returns>
        private void ValidateAddServerToPlacementGroup(Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest)
        {
            if (addServerToPlacementGroupRequest.IsSet && addServerToPlacementGroupRequest.Value == null)
                throw new ArgumentNullException(nameof(addServerToPlacementGroupRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="addServerToPlacementGroupRequest"></param>
        private void AfterAddServerToPlacementGroupDefaultImplementation(IAddServerToPlacementGroupApiResponse apiResponseLocalVar, long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest)
        {
            bool suppressDefaultLog = false;
            AfterAddServerToPlacementGroup(ref suppressDefaultLog, apiResponseLocalVar, id, addServerToPlacementGroupRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="addServerToPlacementGroupRequest"></param>
        partial void AfterAddServerToPlacementGroup(ref bool suppressDefaultLog, IAddServerToPlacementGroupApiResponse apiResponseLocalVar, long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="addServerToPlacementGroupRequest"></param>
        private void OnErrorAddServerToPlacementGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAddServerToPlacementGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, addServerToPlacementGroupRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="addServerToPlacementGroupRequest"></param>
        partial void OnErrorAddServerToPlacementGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest);

        /// <summary>
        /// Add a Server to a Placement Group Adds a Server to a Placement Group.  Server must be powered off for this command to succeed.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="addServerToPlacementGroupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddServerToPlacementGroupApiResponse"/>&gt;</returns>
        public async Task<IAddServerToPlacementGroupApiResponse?> AddServerToPlacementGroupOrDefaultAsync(long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AddServerToPlacementGroupAsync(id, addServerToPlacementGroupRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Add a Server to a Placement Group Adds a Server to a Placement Group.  Server must be powered off for this command to succeed.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="addServerToPlacementGroupRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAddServerToPlacementGroupApiResponse"/>&gt;</returns>
        public async Task<IAddServerToPlacementGroupApiResponse> AddServerToPlacementGroupAsync(long id, Option<AddServerToPlacementGroupRequest> addServerToPlacementGroupRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAddServerToPlacementGroup(addServerToPlacementGroupRequest);

                FormatAddServerToPlacementGroup(ref id, addServerToPlacementGroupRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/add_to_placement_group"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/add_to_placement_group");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (addServerToPlacementGroupRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (addServerToPlacementGroupRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(addServerToPlacementGroupRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AddServerToPlacementGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AddServerToPlacementGroupApiResponse>();

                        AddServerToPlacementGroupApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/add_to_placement_group", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAddServerToPlacementGroupDefaultImplementation(apiResponseLocalVar, id, addServerToPlacementGroupRequest);

                        Events.ExecuteOnAddServerToPlacementGroup(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAddServerToPlacementGroupDefaultImplementation(e, "/servers/{id}/actions/add_to_placement_group", uriBuilderLocalVar.Path, id, addServerToPlacementGroupRequest);
                Events.ExecuteOnErrorAddServerToPlacementGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AddServerToPlacementGroupApiResponse"/>
        /// </summary>
        public partial class AddServerToPlacementGroupApiResponse : Hetzner.Cloud.Client.ApiResponse, IAddServerToPlacementGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AddServerToPlacementGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AddServerToPlacementGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AddServerToPlacementGroupApiResponse(ILogger<AddServerToPlacementGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.AddServerToPlacementGroupResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.AddServerToPlacementGroupResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.AddServerToPlacementGroupResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAttachIsoToServer(ref long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachIsoToServerRequest"></param>
        /// <returns></returns>
        private void ValidateAttachIsoToServer(Option<AttachIsoToServerRequest> attachIsoToServerRequest)
        {
            if (attachIsoToServerRequest.IsSet && attachIsoToServerRequest.Value == null)
                throw new ArgumentNullException(nameof(attachIsoToServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachIsoToServerRequest"></param>
        private void AfterAttachIsoToServerDefaultImplementation(IAttachIsoToServerApiResponse apiResponseLocalVar, long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterAttachIsoToServer(ref suppressDefaultLog, apiResponseLocalVar, id, attachIsoToServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachIsoToServerRequest"></param>
        partial void AfterAttachIsoToServer(ref bool suppressDefaultLog, IAttachIsoToServerApiResponse apiResponseLocalVar, long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachIsoToServerRequest"></param>
        private void OnErrorAttachIsoToServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAttachIsoToServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, attachIsoToServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachIsoToServerRequest"></param>
        partial void OnErrorAttachIsoToServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest);

        /// <summary>
        /// Attach an ISO to a Server Attaches an ISO to a Server. The Server will immediately see it as a new disk. An already attached ISO will automatically be detached before the new ISO is attached.  Servers with attached ISOs have a modified boot order: They will try to boot from the ISO first before falling back to hard disk. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachIsoToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachIsoToServerApiResponse"/>&gt;</returns>
        public async Task<IAttachIsoToServerApiResponse?> AttachIsoToServerOrDefaultAsync(long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AttachIsoToServerAsync(id, attachIsoToServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Attach an ISO to a Server Attaches an ISO to a Server. The Server will immediately see it as a new disk. An already attached ISO will automatically be detached before the new ISO is attached.  Servers with attached ISOs have a modified boot order: They will try to boot from the ISO first before falling back to hard disk. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachIsoToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachIsoToServerApiResponse"/>&gt;</returns>
        public async Task<IAttachIsoToServerApiResponse> AttachIsoToServerAsync(long id, Option<AttachIsoToServerRequest> attachIsoToServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAttachIsoToServer(attachIsoToServerRequest);

                FormatAttachIsoToServer(ref id, attachIsoToServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/attach_iso"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/attach_iso");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (attachIsoToServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (attachIsoToServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(attachIsoToServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AttachIsoToServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AttachIsoToServerApiResponse>();

                        AttachIsoToServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/attach_iso", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAttachIsoToServerDefaultImplementation(apiResponseLocalVar, id, attachIsoToServerRequest);

                        Events.ExecuteOnAttachIsoToServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAttachIsoToServerDefaultImplementation(e, "/servers/{id}/actions/attach_iso", uriBuilderLocalVar.Path, id, attachIsoToServerRequest);
                Events.ExecuteOnErrorAttachIsoToServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AttachIsoToServerApiResponse"/>
        /// </summary>
        public partial class AttachIsoToServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IAttachIsoToServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AttachIsoToServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AttachIsoToServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AttachIsoToServerApiResponse(ILogger<AttachIsoToServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.AttachIsoToServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.AttachIsoToServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.AttachIsoToServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatAttachServerToNetwork(ref long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachServerToNetworkRequest"></param>
        /// <returns></returns>
        private void ValidateAttachServerToNetwork(Option<AttachServerToNetworkRequest> attachServerToNetworkRequest)
        {
            if (attachServerToNetworkRequest.IsSet && attachServerToNetworkRequest.Value == null)
                throw new ArgumentNullException(nameof(attachServerToNetworkRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachServerToNetworkRequest"></param>
        private void AfterAttachServerToNetworkDefaultImplementation(IAttachServerToNetworkApiResponse apiResponseLocalVar, long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest)
        {
            bool suppressDefaultLog = false;
            AfterAttachServerToNetwork(ref suppressDefaultLog, apiResponseLocalVar, id, attachServerToNetworkRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachServerToNetworkRequest"></param>
        partial void AfterAttachServerToNetwork(ref bool suppressDefaultLog, IAttachServerToNetworkApiResponse apiResponseLocalVar, long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachServerToNetworkRequest"></param>
        private void OnErrorAttachServerToNetworkDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAttachServerToNetwork(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, attachServerToNetworkRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachServerToNetworkRequest"></param>
        partial void OnErrorAttachServerToNetwork(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest);

        /// <summary>
        /// Attach a Server to a Network Attaches a Server to a network. This will complement the fixed public Server interface by adding an additional ethernet interface to the Server which is connected to the specified network.  The Server will get an IP auto assigned from a subnet of type &#x60;server&#x60; in the same &#x60;network_zone&#x60;.  Using the &#x60;alias_ips&#x60; attribute you can also define one or more additional IPs to the Servers. Please note that you will have to configure these IPs by hand on your Server since only the primary IP will be given out by DHCP.  **Call specific error codes**  | Code                             | Description                                                           | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;server_already_attached&#x60;        | The server is already attached to the network                         | | &#x60;ip_not_available&#x60;               | The provided Network IP is not available                              | | &#x60;no_subnet_available&#x60;            | No Subnet or IP is available for the Server within the network        | | &#x60;networks_overlap&#x60;               | The network IP range overlaps with one of the server networks         | 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachServerToNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachServerToNetworkApiResponse"/>&gt;</returns>
        public async Task<IAttachServerToNetworkApiResponse?> AttachServerToNetworkOrDefaultAsync(long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AttachServerToNetworkAsync(id, attachServerToNetworkRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Attach a Server to a Network Attaches a Server to a network. This will complement the fixed public Server interface by adding an additional ethernet interface to the Server which is connected to the specified network.  The Server will get an IP auto assigned from a subnet of type &#x60;server&#x60; in the same &#x60;network_zone&#x60;.  Using the &#x60;alias_ips&#x60; attribute you can also define one or more additional IPs to the Servers. Please note that you will have to configure these IPs by hand on your Server since only the primary IP will be given out by DHCP.  **Call specific error codes**  | Code                             | Description                                                           | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;server_already_attached&#x60;        | The server is already attached to the network                         | | &#x60;ip_not_available&#x60;               | The provided Network IP is not available                              | | &#x60;no_subnet_available&#x60;            | No Subnet or IP is available for the Server within the network        | | &#x60;networks_overlap&#x60;               | The network IP range overlaps with one of the server networks         | 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="attachServerToNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachServerToNetworkApiResponse"/>&gt;</returns>
        public async Task<IAttachServerToNetworkApiResponse> AttachServerToNetworkAsync(long id, Option<AttachServerToNetworkRequest> attachServerToNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAttachServerToNetwork(attachServerToNetworkRequest);

                FormatAttachServerToNetwork(ref id, attachServerToNetworkRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/attach_to_network"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/attach_to_network");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (attachServerToNetworkRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (attachServerToNetworkRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(attachServerToNetworkRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AttachServerToNetworkApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AttachServerToNetworkApiResponse>();

                        AttachServerToNetworkApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/attach_to_network", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAttachServerToNetworkDefaultImplementation(apiResponseLocalVar, id, attachServerToNetworkRequest);

                        Events.ExecuteOnAttachServerToNetwork(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAttachServerToNetworkDefaultImplementation(e, "/servers/{id}/actions/attach_to_network", uriBuilderLocalVar.Path, id, attachServerToNetworkRequest);
                Events.ExecuteOnErrorAttachServerToNetwork(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AttachServerToNetworkApiResponse"/>
        /// </summary>
        public partial class AttachServerToNetworkApiResponse : Hetzner.Cloud.Client.ApiResponse, IAttachServerToNetworkApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AttachServerToNetworkApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AttachServerToNetworkApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AttachServerToNetworkApiResponse(ILogger<AttachServerToNetworkApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.AttachServerToNetworkResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.AttachServerToNetworkResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.AttachServerToNetworkResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeAliasIpsOfNetwork(ref long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="changeAliasIpsOfNetworkRequest"></param>
        /// <returns></returns>
        private void ValidateChangeAliasIpsOfNetwork(Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest)
        {
            if (changeAliasIpsOfNetworkRequest.IsSet && changeAliasIpsOfNetworkRequest.Value == null)
                throw new ArgumentNullException(nameof(changeAliasIpsOfNetworkRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeAliasIpsOfNetworkRequest"></param>
        private void AfterChangeAliasIpsOfNetworkDefaultImplementation(IChangeAliasIpsOfNetworkApiResponse apiResponseLocalVar, long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest)
        {
            bool suppressDefaultLog = false;
            AfterChangeAliasIpsOfNetwork(ref suppressDefaultLog, apiResponseLocalVar, id, changeAliasIpsOfNetworkRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeAliasIpsOfNetworkRequest"></param>
        partial void AfterChangeAliasIpsOfNetwork(ref bool suppressDefaultLog, IChangeAliasIpsOfNetworkApiResponse apiResponseLocalVar, long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeAliasIpsOfNetworkRequest"></param>
        private void OnErrorChangeAliasIpsOfNetworkDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeAliasIpsOfNetwork(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, changeAliasIpsOfNetworkRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeAliasIpsOfNetworkRequest"></param>
        partial void OnErrorChangeAliasIpsOfNetwork(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest);

        /// <summary>
        /// Change alias IPs of a Network Changes the alias IPs of an already attached Network. Note that the existing aliases for the specified Network will be replaced with these provided in the request body. So if you want to add an alias IP, you have to provide the existing ones from the Network plus the new alias IP in the request body.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeAliasIpsOfNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeAliasIpsOfNetworkApiResponse"/>&gt;</returns>
        public async Task<IChangeAliasIpsOfNetworkApiResponse?> ChangeAliasIpsOfNetworkOrDefaultAsync(long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeAliasIpsOfNetworkAsync(id, changeAliasIpsOfNetworkRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change alias IPs of a Network Changes the alias IPs of an already attached Network. Note that the existing aliases for the specified Network will be replaced with these provided in the request body. So if you want to add an alias IP, you have to provide the existing ones from the Network plus the new alias IP in the request body.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeAliasIpsOfNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeAliasIpsOfNetworkApiResponse"/>&gt;</returns>
        public async Task<IChangeAliasIpsOfNetworkApiResponse> ChangeAliasIpsOfNetworkAsync(long id, Option<ChangeAliasIpsOfNetworkRequest> changeAliasIpsOfNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeAliasIpsOfNetwork(changeAliasIpsOfNetworkRequest);

                FormatChangeAliasIpsOfNetwork(ref id, changeAliasIpsOfNetworkRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/change_alias_ips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/change_alias_ips");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (changeAliasIpsOfNetworkRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (changeAliasIpsOfNetworkRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(changeAliasIpsOfNetworkRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeAliasIpsOfNetworkApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeAliasIpsOfNetworkApiResponse>();

                        ChangeAliasIpsOfNetworkApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/change_alias_ips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeAliasIpsOfNetworkDefaultImplementation(apiResponseLocalVar, id, changeAliasIpsOfNetworkRequest);

                        Events.ExecuteOnChangeAliasIpsOfNetwork(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeAliasIpsOfNetworkDefaultImplementation(e, "/servers/{id}/actions/change_alias_ips", uriBuilderLocalVar.Path, id, changeAliasIpsOfNetworkRequest);
                Events.ExecuteOnErrorChangeAliasIpsOfNetwork(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeAliasIpsOfNetworkApiResponse"/>
        /// </summary>
        public partial class ChangeAliasIpsOfNetworkApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeAliasIpsOfNetworkApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeAliasIpsOfNetworkApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeAliasIpsOfNetworkApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeAliasIpsOfNetworkApiResponse(ILogger<ChangeAliasIpsOfNetworkApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeAliasIpsOfNetworkResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeAliasIpsOfNetworkResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeAliasIpsOfNetworkResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeReverseDnsEntryForThisServer(ref long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="changeReverseDnsEntryForThisServerRequest"></param>
        /// <returns></returns>
        private void ValidateChangeReverseDnsEntryForThisServer(Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest)
        {
            if (changeReverseDnsEntryForThisServerRequest.IsSet && changeReverseDnsEntryForThisServerRequest.Value == null)
                throw new ArgumentNullException(nameof(changeReverseDnsEntryForThisServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeReverseDnsEntryForThisServerRequest"></param>
        private void AfterChangeReverseDnsEntryForThisServerDefaultImplementation(IChangeReverseDnsEntryForThisServerApiResponse apiResponseLocalVar, long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterChangeReverseDnsEntryForThisServer(ref suppressDefaultLog, apiResponseLocalVar, id, changeReverseDnsEntryForThisServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeReverseDnsEntryForThisServerRequest"></param>
        partial void AfterChangeReverseDnsEntryForThisServer(ref bool suppressDefaultLog, IChangeReverseDnsEntryForThisServerApiResponse apiResponseLocalVar, long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeReverseDnsEntryForThisServerRequest"></param>
        private void OnErrorChangeReverseDnsEntryForThisServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeReverseDnsEntryForThisServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, changeReverseDnsEntryForThisServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeReverseDnsEntryForThisServerRequest"></param>
        partial void OnErrorChangeReverseDnsEntryForThisServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest);

        /// <summary>
        /// Change reverse DNS entry for this Server Changes the hostname that will appear when getting the hostname belonging to the primary IPs (IPv4 and IPv6) of this Server.  Floating IPs assigned to the Server are not affected by this. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeReverseDnsEntryForThisServerRequest">Select the IP address for which to change the DNS entry by passing &#x60;ip&#x60;. It can be either IPv4 or IPv6. The target hostname is set by passing &#x60;dns_ptr&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsEntryForThisServerApiResponse"/>&gt;</returns>
        public async Task<IChangeReverseDnsEntryForThisServerApiResponse?> ChangeReverseDnsEntryForThisServerOrDefaultAsync(long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeReverseDnsEntryForThisServerAsync(id, changeReverseDnsEntryForThisServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change reverse DNS entry for this Server Changes the hostname that will appear when getting the hostname belonging to the primary IPs (IPv4 and IPv6) of this Server.  Floating IPs assigned to the Server are not affected by this. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeReverseDnsEntryForThisServerRequest">Select the IP address for which to change the DNS entry by passing &#x60;ip&#x60;. It can be either IPv4 or IPv6. The target hostname is set by passing &#x60;dns_ptr&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsEntryForThisServerApiResponse"/>&gt;</returns>
        public async Task<IChangeReverseDnsEntryForThisServerApiResponse> ChangeReverseDnsEntryForThisServerAsync(long id, Option<ChangeReverseDnsEntryForThisServerRequest> changeReverseDnsEntryForThisServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeReverseDnsEntryForThisServer(changeReverseDnsEntryForThisServerRequest);

                FormatChangeReverseDnsEntryForThisServer(ref id, changeReverseDnsEntryForThisServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/change_dns_ptr"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/change_dns_ptr");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (changeReverseDnsEntryForThisServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (changeReverseDnsEntryForThisServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(changeReverseDnsEntryForThisServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeReverseDnsEntryForThisServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeReverseDnsEntryForThisServerApiResponse>();

                        ChangeReverseDnsEntryForThisServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/change_dns_ptr", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeReverseDnsEntryForThisServerDefaultImplementation(apiResponseLocalVar, id, changeReverseDnsEntryForThisServerRequest);

                        Events.ExecuteOnChangeReverseDnsEntryForThisServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeReverseDnsEntryForThisServerDefaultImplementation(e, "/servers/{id}/actions/change_dns_ptr", uriBuilderLocalVar.Path, id, changeReverseDnsEntryForThisServerRequest);
                Events.ExecuteOnErrorChangeReverseDnsEntryForThisServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeReverseDnsEntryForThisServerApiResponse"/>
        /// </summary>
        public partial class ChangeReverseDnsEntryForThisServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeReverseDnsEntryForThisServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeReverseDnsEntryForThisServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeReverseDnsEntryForThisServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeReverseDnsEntryForThisServerApiResponse(ILogger<ChangeReverseDnsEntryForThisServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeReverseDnsEntryForThisServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeReverseDnsEntryForThisServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeReverseDnsEntryForThisServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeServerProtection(ref long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="changeServerProtectionRequest"></param>
        /// <returns></returns>
        private void ValidateChangeServerProtection(Option<ChangeServerProtectionRequest> changeServerProtectionRequest)
        {
            if (changeServerProtectionRequest.IsSet && changeServerProtectionRequest.Value == null)
                throw new ArgumentNullException(nameof(changeServerProtectionRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeServerProtectionRequest"></param>
        private void AfterChangeServerProtectionDefaultImplementation(IChangeServerProtectionApiResponse apiResponseLocalVar, long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest)
        {
            bool suppressDefaultLog = false;
            AfterChangeServerProtection(ref suppressDefaultLog, apiResponseLocalVar, id, changeServerProtectionRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeServerProtectionRequest"></param>
        partial void AfterChangeServerProtection(ref bool suppressDefaultLog, IChangeServerProtectionApiResponse apiResponseLocalVar, long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeServerProtectionRequest"></param>
        private void OnErrorChangeServerProtectionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeServerProtection(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, changeServerProtectionRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeServerProtectionRequest"></param>
        partial void OnErrorChangeServerProtection(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest);

        /// <summary>
        /// Change Server Protection Changes the protection configuration of the Server.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeServerProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeServerProtectionApiResponse"/>&gt;</returns>
        public async Task<IChangeServerProtectionApiResponse?> ChangeServerProtectionOrDefaultAsync(long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeServerProtectionAsync(id, changeServerProtectionRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change Server Protection Changes the protection configuration of the Server.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeServerProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeServerProtectionApiResponse"/>&gt;</returns>
        public async Task<IChangeServerProtectionApiResponse> ChangeServerProtectionAsync(long id, Option<ChangeServerProtectionRequest> changeServerProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeServerProtection(changeServerProtectionRequest);

                FormatChangeServerProtection(ref id, changeServerProtectionRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/change_protection"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/change_protection");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (changeServerProtectionRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (changeServerProtectionRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(changeServerProtectionRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeServerProtectionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeServerProtectionApiResponse>();

                        ChangeServerProtectionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/change_protection", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeServerProtectionDefaultImplementation(apiResponseLocalVar, id, changeServerProtectionRequest);

                        Events.ExecuteOnChangeServerProtection(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeServerProtectionDefaultImplementation(e, "/servers/{id}/actions/change_protection", uriBuilderLocalVar.Path, id, changeServerProtectionRequest);
                Events.ExecuteOnErrorChangeServerProtection(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeServerProtectionApiResponse"/>
        /// </summary>
        public partial class ChangeServerProtectionApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeServerProtectionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeServerProtectionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeServerProtectionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeServerProtectionApiResponse(ILogger<ChangeServerProtectionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeServerProtectionResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeServerProtectionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeServerProtectionResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeTypeOfServer(ref long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="changeTypeOfServerRequest"></param>
        /// <returns></returns>
        private void ValidateChangeTypeOfServer(Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest)
        {
            if (changeTypeOfServerRequest.IsSet && changeTypeOfServerRequest.Value == null)
                throw new ArgumentNullException(nameof(changeTypeOfServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeTypeOfServerRequest"></param>
        private void AfterChangeTypeOfServerDefaultImplementation(IChangeTypeOfServerApiResponse apiResponseLocalVar, long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterChangeTypeOfServer(ref suppressDefaultLog, apiResponseLocalVar, id, changeTypeOfServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeTypeOfServerRequest"></param>
        partial void AfterChangeTypeOfServer(ref bool suppressDefaultLog, IChangeTypeOfServerApiResponse apiResponseLocalVar, long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeTypeOfServerRequest"></param>
        private void OnErrorChangeTypeOfServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeTypeOfServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, changeTypeOfServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeTypeOfServerRequest"></param>
        partial void OnErrorChangeTypeOfServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest);

        /// <summary>
        /// Change the Type of a Server Changes the type (Cores, RAM and disk sizes) of a Server.  Server must be powered off for this command to succeed.  This copies the content of its disk, and starts it again.  You can only migrate to Server types with the same &#x60;storage_type&#x60; and equal or bigger disks. Shrinking disks is not possible as it might destroy data.  If the disk gets upgraded, the Server type can not be downgraded any more. If you plan to downgrade the Server type, set &#x60;upgrade_disk&#x60; to &#x60;false&#x60;.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;invalid_server_type&#x60;         | The server type does not fit for the given server or is deprecated   | | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeTypeOfServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeTypeOfServerApiResponse"/>&gt;</returns>
        public async Task<IChangeTypeOfServerApiResponse?> ChangeTypeOfServerOrDefaultAsync(long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeTypeOfServerAsync(id, changeTypeOfServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change the Type of a Server Changes the type (Cores, RAM and disk sizes) of a Server.  Server must be powered off for this command to succeed.  This copies the content of its disk, and starts it again.  You can only migrate to Server types with the same &#x60;storage_type&#x60; and equal or bigger disks. Shrinking disks is not possible as it might destroy data.  If the disk gets upgraded, the Server type can not be downgraded any more. If you plan to downgrade the Server type, set &#x60;upgrade_disk&#x60; to &#x60;false&#x60;.  #### Call specific error codes  | Code                          | Description                                                          | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;invalid_server_type&#x60;         | The server type does not fit for the given server or is deprecated   | | &#x60;server_not_stopped&#x60;          | The action requires a stopped server                                 | 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="changeTypeOfServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeTypeOfServerApiResponse"/>&gt;</returns>
        public async Task<IChangeTypeOfServerApiResponse> ChangeTypeOfServerAsync(long id, Option<ChangeTypeOfServerRequest> changeTypeOfServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeTypeOfServer(changeTypeOfServerRequest);

                FormatChangeTypeOfServer(ref id, changeTypeOfServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/change_type"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/change_type");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (changeTypeOfServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (changeTypeOfServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(changeTypeOfServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeTypeOfServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeTypeOfServerApiResponse>();

                        ChangeTypeOfServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/change_type", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeTypeOfServerDefaultImplementation(apiResponseLocalVar, id, changeTypeOfServerRequest);

                        Events.ExecuteOnChangeTypeOfServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeTypeOfServerDefaultImplementation(e, "/servers/{id}/actions/change_type", uriBuilderLocalVar.Path, id, changeTypeOfServerRequest);
                Events.ExecuteOnErrorChangeTypeOfServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeTypeOfServerApiResponse"/>
        /// </summary>
        public partial class ChangeTypeOfServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeTypeOfServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeTypeOfServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeTypeOfServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeTypeOfServerApiResponse(ILogger<ChangeTypeOfServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeTypeOfServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeTypeOfServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeTypeOfServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateImageFromServer(ref long id, Option<CreateImageFromServerRequest> createImageFromServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createImageFromServerRequest"></param>
        /// <returns></returns>
        private void ValidateCreateImageFromServer(Option<CreateImageFromServerRequest> createImageFromServerRequest)
        {
            if (createImageFromServerRequest.IsSet && createImageFromServerRequest.Value == null)
                throw new ArgumentNullException(nameof(createImageFromServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="createImageFromServerRequest"></param>
        private void AfterCreateImageFromServerDefaultImplementation(ICreateImageFromServerApiResponse apiResponseLocalVar, long id, Option<CreateImageFromServerRequest> createImageFromServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateImageFromServer(ref suppressDefaultLog, apiResponseLocalVar, id, createImageFromServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="createImageFromServerRequest"></param>
        partial void AfterCreateImageFromServer(ref bool suppressDefaultLog, ICreateImageFromServerApiResponse apiResponseLocalVar, long id, Option<CreateImageFromServerRequest> createImageFromServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="createImageFromServerRequest"></param>
        private void OnErrorCreateImageFromServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<CreateImageFromServerRequest> createImageFromServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateImageFromServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, createImageFromServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="createImageFromServerRequest"></param>
        partial void OnErrorCreateImageFromServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<CreateImageFromServerRequest> createImageFromServerRequest);

        /// <summary>
        /// Create Image from a Server Creates an Image (snapshot) from a Server by copying the contents of its disks. This creates a snapshot of the current state of the disk and copies it into an Image. If the Server is currently running you must make sure that its disk content is consistent. Otherwise, the created Image may not be readable.  To make sure disk content is consistent, we recommend to shut down the Server prior to creating an Image.  You can either create a &#x60;backup&#x60; Image that is bound to the Server and therefore will be deleted when the Server is deleted, or you can create a &#x60;snapshot&#x60; Image which is completely independent of the Server it was created from and will survive Server deletion. Backup Images are only available when the backup option is enabled for the Server. Snapshot Images are billed on a per GB basis. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="createImageFromServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateImageFromServerApiResponse"/>&gt;</returns>
        public async Task<ICreateImageFromServerApiResponse?> CreateImageFromServerOrDefaultAsync(long id, Option<CreateImageFromServerRequest> createImageFromServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateImageFromServerAsync(id, createImageFromServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create Image from a Server Creates an Image (snapshot) from a Server by copying the contents of its disks. This creates a snapshot of the current state of the disk and copies it into an Image. If the Server is currently running you must make sure that its disk content is consistent. Otherwise, the created Image may not be readable.  To make sure disk content is consistent, we recommend to shut down the Server prior to creating an Image.  You can either create a &#x60;backup&#x60; Image that is bound to the Server and therefore will be deleted when the Server is deleted, or you can create a &#x60;snapshot&#x60; Image which is completely independent of the Server it was created from and will survive Server deletion. Backup Images are only available when the backup option is enabled for the Server. Snapshot Images are billed on a per GB basis. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="createImageFromServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateImageFromServerApiResponse"/>&gt;</returns>
        public async Task<ICreateImageFromServerApiResponse> CreateImageFromServerAsync(long id, Option<CreateImageFromServerRequest> createImageFromServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateImageFromServer(createImageFromServerRequest);

                FormatCreateImageFromServer(ref id, createImageFromServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/create_image"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/create_image");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (createImageFromServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (createImageFromServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createImageFromServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateImageFromServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateImageFromServerApiResponse>();

                        CreateImageFromServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/create_image", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateImageFromServerDefaultImplementation(apiResponseLocalVar, id, createImageFromServerRequest);

                        Events.ExecuteOnCreateImageFromServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateImageFromServerDefaultImplementation(e, "/servers/{id}/actions/create_image", uriBuilderLocalVar.Path, id, createImageFromServerRequest);
                Events.ExecuteOnErrorCreateImageFromServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateImageFromServerApiResponse"/>
        /// </summary>
        public partial class CreateImageFromServerApiResponse : Hetzner.Cloud.Client.ApiResponse, ICreateImageFromServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateImageFromServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateImageFromServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateImageFromServerApiResponse(ILogger<CreateImageFromServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.CreateImageFromServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.CreateImageFromServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.CreateImageFromServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateServer(Option<CreateServerRequest> createServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createServerRequest"></param>
        /// <returns></returns>
        private void ValidateCreateServer(Option<CreateServerRequest> createServerRequest)
        {
            if (createServerRequest.IsSet && createServerRequest.Value == null)
                throw new ArgumentNullException(nameof(createServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createServerRequest"></param>
        private void AfterCreateServerDefaultImplementation(ICreateServerApiResponse apiResponseLocalVar, Option<CreateServerRequest> createServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateServer(ref suppressDefaultLog, apiResponseLocalVar, createServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createServerRequest"></param>
        partial void AfterCreateServer(ref bool suppressDefaultLog, ICreateServerApiResponse apiResponseLocalVar, Option<CreateServerRequest> createServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createServerRequest"></param>
        private void OnErrorCreateServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateServerRequest> createServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createServerRequest"></param>
        partial void OnErrorCreateServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateServerRequest> createServerRequest);

        /// <summary>
        /// Create a Server Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation.
        /// </summary>
        /// <param name="createServerRequest">Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).  For &#x60;server_type&#x60; you can either use the ID as listed in &#x60;/server_types&#x60; or its name.  For &#x60;image&#x60; you can either use the ID as listed in &#x60;/images&#x60; or its name.  If you want to create the Server in a Location, you must set &#x60;location&#x60; to the ID or name as listed in &#x60;/locations&#x60;. This is the recommended way. You can be even more specific by setting &#x60;datacenter&#x60; to the ID or name as listed in &#x60;/datacenters&#x60;. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.  Some properties like &#x60;start_after_create&#x60; or &#x60;automount&#x60; will trigger Actions after the Server is created. Those Actions are listed in the &#x60;next_actions&#x60; field in the response.  For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in &#x60;ssh_keys&#x60;. If you do not specify any &#x60;ssh_keys&#x60; we will generate a root password for you and return it in the response.  Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.  #### Call specific error codes  | Code                             | Description                                                | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;placement_error&#x60;                | An error during the placement occurred                     | | &#x60;primary_ip_assigned&#x60;            | The specified Primary IP is already assigned to a server   | | &#x60;primary_ip_datacenter_mismatch&#x60; | The specified Primary IP is in a different datacenter      | | &#x60;primary_ip_version_mismatch&#x60;    | The specified Primary IP has the wrong IP Version          |  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateServerApiResponse"/>&gt;</returns>
        public async Task<ICreateServerApiResponse?> CreateServerOrDefaultAsync(Option<CreateServerRequest> createServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateServerAsync(createServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Server Creates a new Server. Returns preliminary information about the Server as well as an Action that covers progress of creation.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createServerRequest">Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes).  For &#x60;server_type&#x60; you can either use the ID as listed in &#x60;/server_types&#x60; or its name.  For &#x60;image&#x60; you can either use the ID as listed in &#x60;/images&#x60; or its name.  If you want to create the Server in a Location, you must set &#x60;location&#x60; to the ID or name as listed in &#x60;/locations&#x60;. This is the recommended way. You can be even more specific by setting &#x60;datacenter&#x60; to the ID or name as listed in &#x60;/datacenters&#x60;. However we only recommend this if you want to assign a specific Primary IP to the Server which is located in the specified Datacenter.  Some properties like &#x60;start_after_create&#x60; or &#x60;automount&#x60; will trigger Actions after the Server is created. Those Actions are listed in the &#x60;next_actions&#x60; field in the response.  For accessing your Server we strongly recommend to use SSH keys by passing the respective key IDs in &#x60;ssh_keys&#x60;. If you do not specify any &#x60;ssh_keys&#x60; we will generate a root password for you and return it in the response.  Please note that provided user-data is stored in our systems. While we take measures to protect it we highly recommend that you don’t use it to store passwords or other sensitive information.  #### Call specific error codes  | Code                             | Description                                                | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | &#x60;placement_error&#x60;                | An error during the placement occurred                     | | &#x60;primary_ip_assigned&#x60;            | The specified Primary IP is already assigned to a server   | | &#x60;primary_ip_datacenter_mismatch&#x60; | The specified Primary IP is in a different datacenter      | | &#x60;primary_ip_version_mismatch&#x60;    | The specified Primary IP has the wrong IP Version          |  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateServerApiResponse"/>&gt;</returns>
        public async Task<ICreateServerApiResponse> CreateServerAsync(Option<CreateServerRequest> createServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateServer(createServerRequest);

                FormatCreateServer(createServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers");

                    if (createServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (createServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateServerApiResponse>();

                        CreateServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateServerDefaultImplementation(apiResponseLocalVar, createServerRequest);

                        Events.ExecuteOnCreateServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateServerDefaultImplementation(e, "/servers", uriBuilderLocalVar.Path, createServerRequest);
                Events.ExecuteOnErrorCreateServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateServerApiResponse"/>
        /// </summary>
        public partial class CreateServerApiResponse : Hetzner.Cloud.Client.ApiResponse, ICreateServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateServerApiResponse(ILogger<CreateServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.CreateServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.CreateServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.CreateServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteServerDefaultImplementation(IDeleteServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteServer(ref bool suppressDefaultLog, IDeleteServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Delete a Server Deletes a Server. This immediately removes the Server from your account, and it is no longer accessible. Any resources attached to the server (like Volumes, Primary IPs, Floating IPs, Firewalls, Placement Groups) are detached while the server is deleted. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteServerApiResponse"/>&gt;</returns>
        public async Task<IDeleteServerApiResponse?> DeleteServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a Server Deletes a Server. This immediately removes the Server from your account, and it is no longer accessible. Any resources attached to the server (like Volumes, Primary IPs, Floating IPs, Firewalls, Placement Groups) are detached while the server is deleted. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteServerApiResponse"/>&gt;</returns>
        public async Task<IDeleteServerApiResponse> DeleteServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteServerApiResponse>();

                        DeleteServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteServerDefaultImplementation(e, "/servers/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteServerApiResponse"/>
        /// </summary>
        public partial class DeleteServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IDeleteServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteServerApiResponse(ILogger<DeleteServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.DeleteServerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.DeleteServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.DeleteServerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDetachIsoFromServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDetachIsoFromServerDefaultImplementation(IDetachIsoFromServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDetachIsoFromServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDetachIsoFromServer(ref bool suppressDefaultLog, IDetachIsoFromServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDetachIsoFromServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDetachIsoFromServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDetachIsoFromServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Detach an ISO from a Server Detaches an ISO from a Server. In case no ISO Image is attached to the Server, the status of the returned Action is immediately set to &#x60;success&#x60;
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachIsoFromServerApiResponse"/>&gt;</returns>
        public async Task<IDetachIsoFromServerApiResponse?> DetachIsoFromServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DetachIsoFromServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Detach an ISO from a Server Detaches an ISO from a Server. In case no ISO Image is attached to the Server, the status of the returned Action is immediately set to &#x60;success&#x60;
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachIsoFromServerApiResponse"/>&gt;</returns>
        public async Task<IDetachIsoFromServerApiResponse> DetachIsoFromServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDetachIsoFromServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/detach_iso"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/detach_iso");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DetachIsoFromServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DetachIsoFromServerApiResponse>();

                        DetachIsoFromServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/detach_iso", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDetachIsoFromServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDetachIsoFromServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDetachIsoFromServerDefaultImplementation(e, "/servers/{id}/actions/detach_iso", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDetachIsoFromServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DetachIsoFromServerApiResponse"/>
        /// </summary>
        public partial class DetachIsoFromServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IDetachIsoFromServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DetachIsoFromServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DetachIsoFromServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DetachIsoFromServerApiResponse(ILogger<DetachIsoFromServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.DetachIsoFromServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.DetachIsoFromServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.DetachIsoFromServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDetachServerFromNetwork(ref long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="detachServerFromNetworkRequest"></param>
        /// <returns></returns>
        private void ValidateDetachServerFromNetwork(Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest)
        {
            if (detachServerFromNetworkRequest.IsSet && detachServerFromNetworkRequest.Value == null)
                throw new ArgumentNullException(nameof(detachServerFromNetworkRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="detachServerFromNetworkRequest"></param>
        private void AfterDetachServerFromNetworkDefaultImplementation(IDetachServerFromNetworkApiResponse apiResponseLocalVar, long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest)
        {
            bool suppressDefaultLog = false;
            AfterDetachServerFromNetwork(ref suppressDefaultLog, apiResponseLocalVar, id, detachServerFromNetworkRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="detachServerFromNetworkRequest"></param>
        partial void AfterDetachServerFromNetwork(ref bool suppressDefaultLog, IDetachServerFromNetworkApiResponse apiResponseLocalVar, long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="detachServerFromNetworkRequest"></param>
        private void OnErrorDetachServerFromNetworkDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDetachServerFromNetwork(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, detachServerFromNetworkRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="detachServerFromNetworkRequest"></param>
        partial void OnErrorDetachServerFromNetwork(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest);

        /// <summary>
        /// Detach a Server from a Network Detaches a Server from a network. The interface for this network will vanish.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="detachServerFromNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachServerFromNetworkApiResponse"/>&gt;</returns>
        public async Task<IDetachServerFromNetworkApiResponse?> DetachServerFromNetworkOrDefaultAsync(long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DetachServerFromNetworkAsync(id, detachServerFromNetworkRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Detach a Server from a Network Detaches a Server from a network. The interface for this network will vanish.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="detachServerFromNetworkRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachServerFromNetworkApiResponse"/>&gt;</returns>
        public async Task<IDetachServerFromNetworkApiResponse> DetachServerFromNetworkAsync(long id, Option<DetachServerFromNetworkRequest> detachServerFromNetworkRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateDetachServerFromNetwork(detachServerFromNetworkRequest);

                FormatDetachServerFromNetwork(ref id, detachServerFromNetworkRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/detach_from_network"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/detach_from_network");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (detachServerFromNetworkRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (detachServerFromNetworkRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(detachServerFromNetworkRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DetachServerFromNetworkApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DetachServerFromNetworkApiResponse>();

                        DetachServerFromNetworkApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/detach_from_network", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDetachServerFromNetworkDefaultImplementation(apiResponseLocalVar, id, detachServerFromNetworkRequest);

                        Events.ExecuteOnDetachServerFromNetwork(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDetachServerFromNetworkDefaultImplementation(e, "/servers/{id}/actions/detach_from_network", uriBuilderLocalVar.Path, id, detachServerFromNetworkRequest);
                Events.ExecuteOnErrorDetachServerFromNetwork(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DetachServerFromNetworkApiResponse"/>
        /// </summary>
        public partial class DetachServerFromNetworkApiResponse : Hetzner.Cloud.Client.ApiResponse, IDetachServerFromNetworkApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DetachServerFromNetworkApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DetachServerFromNetworkApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DetachServerFromNetworkApiResponse(ILogger<DetachServerFromNetworkApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.DetachServerFromNetworkResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.DetachServerFromNetworkResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.DetachServerFromNetworkResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDisableBackupsForServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDisableBackupsForServerDefaultImplementation(IDisableBackupsForServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDisableBackupsForServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDisableBackupsForServer(ref bool suppressDefaultLog, IDisableBackupsForServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDisableBackupsForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDisableBackupsForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDisableBackupsForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Disable Backups for a Server Disables the automatic backup option and deletes all existing Backups for a Server. No more additional charges for backups will be made.  Caution: This immediately removes all existing backups for the Server! 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableBackupsForServerApiResponse"/>&gt;</returns>
        public async Task<IDisableBackupsForServerApiResponse?> DisableBackupsForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DisableBackupsForServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Disable Backups for a Server Disables the automatic backup option and deletes all existing Backups for a Server. No more additional charges for backups will be made.  Caution: This immediately removes all existing backups for the Server! 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableBackupsForServerApiResponse"/>&gt;</returns>
        public async Task<IDisableBackupsForServerApiResponse> DisableBackupsForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDisableBackupsForServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/disable_backup"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/disable_backup");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DisableBackupsForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DisableBackupsForServerApiResponse>();

                        DisableBackupsForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/disable_backup", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDisableBackupsForServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDisableBackupsForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDisableBackupsForServerDefaultImplementation(e, "/servers/{id}/actions/disable_backup", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDisableBackupsForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DisableBackupsForServerApiResponse"/>
        /// </summary>
        public partial class DisableBackupsForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IDisableBackupsForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DisableBackupsForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DisableBackupsForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DisableBackupsForServerApiResponse(ILogger<DisableBackupsForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.DisableBackupsForServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.DisableBackupsForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.DisableBackupsForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDisableRescueModeForServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDisableRescueModeForServerDefaultImplementation(IDisableRescueModeForServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDisableRescueModeForServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDisableRescueModeForServer(ref bool suppressDefaultLog, IDisableRescueModeForServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDisableRescueModeForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDisableRescueModeForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDisableRescueModeForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Disable Rescue Mode for a Server Disables the Hetzner Rescue System for a Server. This makes a Server start from its disks on next reboot.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Disabling rescue mode will not reboot your Server — you will have to do this yourself. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableRescueModeForServerApiResponse"/>&gt;</returns>
        public async Task<IDisableRescueModeForServerApiResponse?> DisableRescueModeForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DisableRescueModeForServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Disable Rescue Mode for a Server Disables the Hetzner Rescue System for a Server. This makes a Server start from its disks on next reboot.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Disabling rescue mode will not reboot your Server — you will have to do this yourself. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDisableRescueModeForServerApiResponse"/>&gt;</returns>
        public async Task<IDisableRescueModeForServerApiResponse> DisableRescueModeForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDisableRescueModeForServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/disable_rescue"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/disable_rescue");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DisableRescueModeForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DisableRescueModeForServerApiResponse>();

                        DisableRescueModeForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/disable_rescue", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDisableRescueModeForServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDisableRescueModeForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDisableRescueModeForServerDefaultImplementation(e, "/servers/{id}/actions/disable_rescue", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDisableRescueModeForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DisableRescueModeForServerApiResponse"/>
        /// </summary>
        public partial class DisableRescueModeForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IDisableRescueModeForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DisableRescueModeForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DisableRescueModeForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DisableRescueModeForServerApiResponse(ILogger<DisableRescueModeForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.DisableRescueModeForServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.DisableRescueModeForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.DisableRescueModeForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEnableAndConfigureBackupsForServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterEnableAndConfigureBackupsForServerDefaultImplementation(IEnableAndConfigureBackupsForServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterEnableAndConfigureBackupsForServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterEnableAndConfigureBackupsForServer(ref bool suppressDefaultLog, IEnableAndConfigureBackupsForServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorEnableAndConfigureBackupsForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEnableAndConfigureBackupsForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorEnableAndConfigureBackupsForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Enable and Configure Backups for a Server Enables and configures the automatic daily backup option for the Server. Enabling automatic backups will increase the price of the Server by 20%. In return, you will get seven slots where Images of type backup can be stored.  Backups are automatically created daily. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableAndConfigureBackupsForServerApiResponse"/>&gt;</returns>
        public async Task<IEnableAndConfigureBackupsForServerApiResponse?> EnableAndConfigureBackupsForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EnableAndConfigureBackupsForServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Enable and Configure Backups for a Server Enables and configures the automatic daily backup option for the Server. Enabling automatic backups will increase the price of the Server by 20%. In return, you will get seven slots where Images of type backup can be stored.  Backups are automatically created daily. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableAndConfigureBackupsForServerApiResponse"/>&gt;</returns>
        public async Task<IEnableAndConfigureBackupsForServerApiResponse> EnableAndConfigureBackupsForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatEnableAndConfigureBackupsForServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/enable_backup"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/enable_backup");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EnableAndConfigureBackupsForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EnableAndConfigureBackupsForServerApiResponse>();

                        EnableAndConfigureBackupsForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/enable_backup", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEnableAndConfigureBackupsForServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnEnableAndConfigureBackupsForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEnableAndConfigureBackupsForServerDefaultImplementation(e, "/servers/{id}/actions/enable_backup", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorEnableAndConfigureBackupsForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EnableAndConfigureBackupsForServerApiResponse"/>
        /// </summary>
        public partial class EnableAndConfigureBackupsForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IEnableAndConfigureBackupsForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EnableAndConfigureBackupsForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EnableAndConfigureBackupsForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EnableAndConfigureBackupsForServerApiResponse(ILogger<EnableAndConfigureBackupsForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.EnableAndConfigureBackupsForServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.EnableAndConfigureBackupsForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.EnableAndConfigureBackupsForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatEnableRescueModeForServer(ref long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="enableRescueModeForServerRequest"></param>
        /// <returns></returns>
        private void ValidateEnableRescueModeForServer(Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest)
        {
            if (enableRescueModeForServerRequest.IsSet && enableRescueModeForServerRequest.Value == null)
                throw new ArgumentNullException(nameof(enableRescueModeForServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="enableRescueModeForServerRequest"></param>
        private void AfterEnableRescueModeForServerDefaultImplementation(IEnableRescueModeForServerApiResponse apiResponseLocalVar, long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterEnableRescueModeForServer(ref suppressDefaultLog, apiResponseLocalVar, id, enableRescueModeForServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="enableRescueModeForServerRequest"></param>
        partial void AfterEnableRescueModeForServer(ref bool suppressDefaultLog, IEnableRescueModeForServerApiResponse apiResponseLocalVar, long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="enableRescueModeForServerRequest"></param>
        private void OnErrorEnableRescueModeForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEnableRescueModeForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, enableRescueModeForServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="enableRescueModeForServerRequest"></param>
        partial void OnErrorEnableRescueModeForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest);

        /// <summary>
        /// Enable Rescue Mode for a Server Enable the Hetzner Rescue System for this Server. The next time a Server with enabled rescue mode boots it will start a special minimal Linux distribution designed for repair and reinstall.  In case a Server cannot boot on its own you can use this to access a Server’s disks.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Enabling rescue mode will not [reboot](https://docs.hetzner.cloud/#server-actions-soft-reboot-a-server) your Server — you will have to do this yourself. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="enableRescueModeForServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableRescueModeForServerApiResponse"/>&gt;</returns>
        public async Task<IEnableRescueModeForServerApiResponse?> EnableRescueModeForServerOrDefaultAsync(long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EnableRescueModeForServerAsync(id, enableRescueModeForServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Enable Rescue Mode for a Server Enable the Hetzner Rescue System for this Server. The next time a Server with enabled rescue mode boots it will start a special minimal Linux distribution designed for repair and reinstall.  In case a Server cannot boot on its own you can use this to access a Server’s disks.  Rescue Mode is automatically disabled when you first boot into it or if you do not use it for 60 minutes.  Enabling rescue mode will not [reboot](https://docs.hetzner.cloud/#server-actions-soft-reboot-a-server) your Server — you will have to do this yourself. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="enableRescueModeForServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnableRescueModeForServerApiResponse"/>&gt;</returns>
        public async Task<IEnableRescueModeForServerApiResponse> EnableRescueModeForServerAsync(long id, Option<EnableRescueModeForServerRequest> enableRescueModeForServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateEnableRescueModeForServer(enableRescueModeForServerRequest);

                FormatEnableRescueModeForServer(ref id, enableRescueModeForServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/enable_rescue"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/enable_rescue");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (enableRescueModeForServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (enableRescueModeForServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(enableRescueModeForServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<EnableRescueModeForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EnableRescueModeForServerApiResponse>();

                        EnableRescueModeForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/enable_rescue", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterEnableRescueModeForServerDefaultImplementation(apiResponseLocalVar, id, enableRescueModeForServerRequest);

                        Events.ExecuteOnEnableRescueModeForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEnableRescueModeForServerDefaultImplementation(e, "/servers/{id}/actions/enable_rescue", uriBuilderLocalVar.Path, id, enableRescueModeForServerRequest);
                Events.ExecuteOnErrorEnableRescueModeForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EnableRescueModeForServerApiResponse"/>
        /// </summary>
        public partial class EnableRescueModeForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IEnableRescueModeForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EnableRescueModeForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EnableRescueModeForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EnableRescueModeForServerApiResponse(ILogger<EnableRescueModeForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.EnableRescueModeForServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.EnableRescueModeForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.EnableRescueModeForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetActionForServer(ref long id, ref long actionId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void AfterGetActionForServerDefaultImplementation(IGetActionForServerApiResponse apiResponseLocalVar, long id, long actionId)
        {
            bool suppressDefaultLog = false;
            AfterGetActionForServer(ref suppressDefaultLog, apiResponseLocalVar, id, actionId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void AfterGetActionForServer(ref bool suppressDefaultLog, IGetActionForServerApiResponse apiResponseLocalVar, long id, long actionId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void OnErrorGetActionForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetActionForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, actionId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void OnErrorGetActionForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId);

        /// <summary>
        /// Get an Action for a Server Returns a specific Action object for a Server.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForServerApiResponse"/>&gt;</returns>
        public async Task<IGetActionForServerApiResponse?> GetActionForServerOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetActionForServerAsync(id, actionId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action for a Server Returns a specific Action object for a Server.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForServerApiResponse"/>&gt;</returns>
        public async Task<IGetActionForServerApiResponse> GetActionForServerAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetActionForServer(ref id, ref actionId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/{action_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/{action_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baction_id%7D", Uri.EscapeDataString(actionId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetActionForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetActionForServerApiResponse>();

                        GetActionForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/{action_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetActionForServerDefaultImplementation(apiResponseLocalVar, id, actionId);

                        Events.ExecuteOnGetActionForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetActionForServerDefaultImplementation(e, "/servers/{id}/actions/{action_id}", uriBuilderLocalVar.Path, id, actionId);
                Events.ExecuteOnErrorGetActionForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetActionForServerApiResponse"/>
        /// </summary>
        public partial class GetActionForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetActionForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetActionForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetActionForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetActionForServerApiResponse(ILogger<GetActionForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionForServerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetMetricsForServer(ref long id, ref string type, ref string start, ref string end, ref Option<string> step);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="type"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="step"></param>
        /// <returns></returns>
        private void ValidateGetMetricsForServer(string type, string start, string end, Option<string> step)
        {
            if (type == null)
                throw new ArgumentNullException(nameof(type));

            if (start == null)
                throw new ArgumentNullException(nameof(start));

            if (end == null)
                throw new ArgumentNullException(nameof(end));

            if (step.IsSet && step.Value == null)
                throw new ArgumentNullException(nameof(step));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="step"></param>
        private void AfterGetMetricsForServerDefaultImplementation(IGetMetricsForServerApiResponse apiResponseLocalVar, long id, string type, string start, string end, Option<string> step)
        {
            bool suppressDefaultLog = false;
            AfterGetMetricsForServer(ref suppressDefaultLog, apiResponseLocalVar, id, type, start, end, step);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="step"></param>
        partial void AfterGetMetricsForServer(ref bool suppressDefaultLog, IGetMetricsForServerApiResponse apiResponseLocalVar, long id, string type, string start, string end, Option<string> step);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="step"></param>
        private void OnErrorGetMetricsForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, string type, string start, string end, Option<string> step)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetMetricsForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, type, start, end, step);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="start"></param>
        /// <param name="end"></param>
        /// <param name="step"></param>
        partial void OnErrorGetMetricsForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, string type, string start, string end, Option<string> step);

        /// <summary>
        /// Get Metrics for a Server Get Metrics for specified Server.  You must specify the type of metric to get: cpu, disk or network. You can also specify more than one type by comma separation, e.g. cpu,disk.  Depending on the type you will get different time series data  | Type    | Timeseries              | Unit      | Description                                          | |- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | cpu     | cpu                     | percent   | Percent CPU usage                                    | | disk    | disk.0.iops.read        | iop/s     | Number of read IO operations per second              | |         | disk.0.iops.write       | iop/s     | Number of write IO operations per second             | |         | disk.0.bandwidth.read   | bytes/s   | Bytes read per second                                | |         | disk.0.bandwidth.write  | bytes/s   | Bytes written per second                             | | network | network.0.pps.in        | packets/s | Public Network interface packets per second received | |         | network.0.pps.out       | packets/s | Public Network interface packets per second sent     | |         | network.0.bandwidth.in  | bytes/s   | Public Network interface bytes/s received            | |         | network.0.bandwidth.out | bytes/s   | Public Network interface bytes/s sent                |  Metrics are available for the last 30 days only.  If you do not provide the step argument we will automatically adjust it so that a maximum of 200 samples are returned.  We limit the number of samples returned to a maximum of 500 and will adjust the step parameter accordingly. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="type">Type of metrics to get</param>
        /// <param name="start">Start of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="end">End of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="step">Resolution of results in seconds (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMetricsForServerApiResponse"/>&gt;</returns>
        public async Task<IGetMetricsForServerApiResponse?> GetMetricsForServerOrDefaultAsync(long id, string type, string start, string end, Option<string> step = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetMetricsForServerAsync(id, type, start, end, step, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get Metrics for a Server Get Metrics for specified Server.  You must specify the type of metric to get: cpu, disk or network. You can also specify more than one type by comma separation, e.g. cpu,disk.  Depending on the type you will get different time series data  | Type    | Timeseries              | Unit      | Description                                          | |- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -| | cpu     | cpu                     | percent   | Percent CPU usage                                    | | disk    | disk.0.iops.read        | iop/s     | Number of read IO operations per second              | |         | disk.0.iops.write       | iop/s     | Number of write IO operations per second             | |         | disk.0.bandwidth.read   | bytes/s   | Bytes read per second                                | |         | disk.0.bandwidth.write  | bytes/s   | Bytes written per second                             | | network | network.0.pps.in        | packets/s | Public Network interface packets per second received | |         | network.0.pps.out       | packets/s | Public Network interface packets per second sent     | |         | network.0.bandwidth.in  | bytes/s   | Public Network interface bytes/s received            | |         | network.0.bandwidth.out | bytes/s   | Public Network interface bytes/s sent                |  Metrics are available for the last 30 days only.  If you do not provide the step argument we will automatically adjust it so that a maximum of 200 samples are returned.  We limit the number of samples returned to a maximum of 500 and will adjust the step parameter accordingly. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="type">Type of metrics to get</param>
        /// <param name="start">Start of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="end">End of period to get Metrics for (in ISO-8601 format)</param>
        /// <param name="step">Resolution of results in seconds (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetMetricsForServerApiResponse"/>&gt;</returns>
        public async Task<IGetMetricsForServerApiResponse> GetMetricsForServerAsync(long id, string type, string start, string end, Option<string> step = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetMetricsForServer(type, start, end, step);

                FormatGetMetricsForServer(ref id, ref type, ref start, ref end, ref step);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/metrics"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/metrics");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["type"] = ClientUtils.ParameterToString(type);
                    parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start);
                    parseQueryStringLocalVar["end"] = ClientUtils.ParameterToString(end);

                    if (step.IsSet)
                        parseQueryStringLocalVar["step"] = ClientUtils.ParameterToString(step.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetMetricsForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetMetricsForServerApiResponse>();

                        GetMetricsForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/metrics", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetMetricsForServerDefaultImplementation(apiResponseLocalVar, id, type, start, end, step);

                        Events.ExecuteOnGetMetricsForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetMetricsForServerDefaultImplementation(e, "/servers/{id}/metrics", uriBuilderLocalVar.Path, id, type, start, end, step);
                Events.ExecuteOnErrorGetMetricsForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetMetricsForServerApiResponse"/>
        /// </summary>
        public partial class GetMetricsForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetMetricsForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetMetricsForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetMetricsForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetMetricsForServerApiResponse(ILogger<GetMetricsForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetMetricsForServerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetMetricsForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetMetricsForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetServerDefaultImplementation(IGetServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetServer(ref bool suppressDefaultLog, IGetServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get a Server Returns a specific Server object. The Server must exist inside the Project
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerApiResponse"/>&gt;</returns>
        public async Task<IGetServerApiResponse?> GetServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a Server Returns a specific Server object. The Server must exist inside the Project
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerApiResponse"/>&gt;</returns>
        public async Task<IGetServerApiResponse> GetServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetServerApiResponse>();

                        GetServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetServerDefaultImplementation(e, "/servers/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetServerApiResponse"/>
        /// </summary>
        public partial class GetServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetServerApiResponse(ILogger<GetServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetServerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetServerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetServerAction(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetServerActionDefaultImplementation(IGetServerActionApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetServerAction(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetServerAction(ref bool suppressDefaultLog, IGetServerActionApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetServerActionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetServerAction(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetServerAction(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get an Action Returns a specific Action object.
        /// </summary>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerActionApiResponse"/>&gt;</returns>
        public async Task<IGetServerActionApiResponse?> GetServerActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetServerActionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action Returns a specific Action object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetServerActionApiResponse"/>&gt;</returns>
        public async Task<IGetServerActionApiResponse> GetServerActionAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetServerAction(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/actions/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/actions/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetServerActionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetServerActionApiResponse>();

                        GetServerActionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/actions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetServerActionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetServerAction(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetServerActionDefaultImplementation(e, "/servers/actions/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetServerAction(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetServerActionApiResponse"/>
        /// </summary>
        public partial class GetServerActionApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetServerActionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetServerActionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetServerActionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetServerActionApiResponse(ILogger<GetServerActionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListActionsForServer(ref long id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListActionsForServer(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListActionsForServerDefaultImplementation(IListActionsForServerApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListActionsForServer(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListActionsForServer(ref bool suppressDefaultLog, IListActionsForServerApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListActionsForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListActionsForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListActionsForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions for a Server Returns all Action objects for a Server. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </summary>
        /// <param name="id">ID of the Server</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForServerApiResponse"/>&gt;</returns>
        public async Task<IListActionsForServerApiResponse?> ListActionsForServerOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListActionsForServerAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions for a Server Returns all Action objects for a Server. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForServerApiResponse"/>&gt;</returns>
        public async Task<IListActionsForServerApiResponse> ListActionsForServerAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListActionsForServer(sort, status);

                FormatListActionsForServer(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListActionsForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListActionsForServerApiResponse>();

                        ListActionsForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListActionsForServerDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListActionsForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListActionsForServerDefaultImplementation(e, "/servers/{id}/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListActionsForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListActionsForServerApiResponse"/>
        /// </summary>
        public partial class ListActionsForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IListActionsForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListActionsForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListActionsForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListActionsForServerApiResponse(ILogger<ListActionsForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsForServerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListServerActions(ref Option<long> id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListServerActions(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListServerActionsDefaultImplementation(IListServerActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListServerActions(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListServerActions(ref bool suppressDefaultLog, IListServerActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListServerActionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListServerActions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListServerActions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </summary>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServerActionsApiResponse"/>&gt;</returns>
        public async Task<IListServerActionsApiResponse?> ListServerActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListServerActionsAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServerActionsApiResponse"/>&gt;</returns>
        public async Task<IListServerActionsApiResponse> ListServerActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListServerActions(sort, status);

                FormatListServerActions(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/actions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListServerActionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListServerActionsApiResponse>();

                        ListServerActionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListServerActionsDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListServerActions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListServerActionsDefaultImplementation(e, "/servers/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListServerActions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListServerActionsApiResponse"/>
        /// </summary>
        public partial class ListServerActionsApiResponse : Hetzner.Cloud.Client.ApiResponse, IListServerActionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListServerActionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListServerActionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListServerActionsApiResponse(ILogger<ListServerActionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListServers(ref Option<string> name, ref Option<string> labelSelector, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListServers(Option<string> name, Option<string> labelSelector, Option<string> sort, Option<string> status)
        {
            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (labelSelector.IsSet && labelSelector.Value == null)
                throw new ArgumentNullException(nameof(labelSelector));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListServersDefaultImplementation(IListServersApiResponse apiResponseLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListServers(ref suppressDefaultLog, apiResponseLocalVar, name, labelSelector, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListServers(ref bool suppressDefaultLog, IListServersApiResponse apiResponseLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListServersDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListServers(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name, labelSelector, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListServers(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Servers Returns all existing Server objects
        /// </summary>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Can be used multiple times. The response will only contain Server matching the status (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServersApiResponse"/>&gt;</returns>
        public async Task<IListServersApiResponse?> ListServersOrDefaultAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListServersAsync(name, labelSelector, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Servers Returns all existing Server objects
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Can be used multiple times. The response will only contain Server matching the status (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListServersApiResponse"/>&gt;</returns>
        public async Task<IListServersApiResponse> ListServersAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListServers(name, labelSelector, sort, status);

                FormatListServers(ref name, ref labelSelector, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (labelSelector.IsSet)
                        parseQueryStringLocalVar["label_selector"] = ClientUtils.ParameterToString(labelSelector.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListServersApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListServersApiResponse>();

                        ListServersApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListServersDefaultImplementation(apiResponseLocalVar, name, labelSelector, sort, status, page, perPage);

                        Events.ExecuteOnListServers(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListServersDefaultImplementation(e, "/servers", uriBuilderLocalVar.Path, name, labelSelector, sort, status, page, perPage);
                Events.ExecuteOnErrorListServers(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListServersApiResponse"/>
        /// </summary>
        public partial class ListServersApiResponse : Hetzner.Cloud.Client.ApiResponse, IListServersApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListServersApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListServersApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListServersApiResponse(ILogger<ListServersApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListServersResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListServersResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListServersResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPowerOffServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterPowerOffServerDefaultImplementation(IPowerOffServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterPowerOffServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterPowerOffServer(ref bool suppressDefaultLog, IPowerOffServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorPowerOffServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPowerOffServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorPowerOffServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Power off a Server Cuts power to the Server. This forcefully stops it without giving the Server operating system time to gracefully stop. May lead to data loss, equivalent to pulling the power cord. Power off should only be used when shutdown does not work.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOffServerApiResponse"/>&gt;</returns>
        public async Task<IPowerOffServerApiResponse?> PowerOffServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PowerOffServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Power off a Server Cuts power to the Server. This forcefully stops it without giving the Server operating system time to gracefully stop. May lead to data loss, equivalent to pulling the power cord. Power off should only be used when shutdown does not work.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOffServerApiResponse"/>&gt;</returns>
        public async Task<IPowerOffServerApiResponse> PowerOffServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatPowerOffServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/poweroff"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/poweroff");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PowerOffServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PowerOffServerApiResponse>();

                        PowerOffServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/poweroff", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPowerOffServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnPowerOffServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPowerOffServerDefaultImplementation(e, "/servers/{id}/actions/poweroff", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorPowerOffServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PowerOffServerApiResponse"/>
        /// </summary>
        public partial class PowerOffServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IPowerOffServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PowerOffServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PowerOffServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PowerOffServerApiResponse(ILogger<PowerOffServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.PowerOffServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.PowerOffServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.PowerOffServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPowerOnServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterPowerOnServerDefaultImplementation(IPowerOnServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterPowerOnServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterPowerOnServer(ref bool suppressDefaultLog, IPowerOnServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorPowerOnServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPowerOnServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorPowerOnServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Power on a Server Starts a Server by turning its power on.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOnServerApiResponse"/>&gt;</returns>
        public async Task<IPowerOnServerApiResponse?> PowerOnServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PowerOnServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Power on a Server Starts a Server by turning its power on.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPowerOnServerApiResponse"/>&gt;</returns>
        public async Task<IPowerOnServerApiResponse> PowerOnServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatPowerOnServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/poweron"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/poweron");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<PowerOnServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PowerOnServerApiResponse>();

                        PowerOnServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/poweron", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterPowerOnServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnPowerOnServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPowerOnServerDefaultImplementation(e, "/servers/{id}/actions/poweron", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorPowerOnServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PowerOnServerApiResponse"/>
        /// </summary>
        public partial class PowerOnServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IPowerOnServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PowerOnServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PowerOnServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PowerOnServerApiResponse(ILogger<PowerOnServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.PowerOnServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.PowerOnServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.PowerOnServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRebuildServerFromImage(ref long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="rebuildServerFromImageRequest"></param>
        /// <returns></returns>
        private void ValidateRebuildServerFromImage(Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest)
        {
            if (rebuildServerFromImageRequest.IsSet && rebuildServerFromImageRequest.Value == null)
                throw new ArgumentNullException(nameof(rebuildServerFromImageRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="rebuildServerFromImageRequest"></param>
        private void AfterRebuildServerFromImageDefaultImplementation(IRebuildServerFromImageApiResponse apiResponseLocalVar, long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest)
        {
            bool suppressDefaultLog = false;
            AfterRebuildServerFromImage(ref suppressDefaultLog, apiResponseLocalVar, id, rebuildServerFromImageRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="rebuildServerFromImageRequest"></param>
        partial void AfterRebuildServerFromImage(ref bool suppressDefaultLog, IRebuildServerFromImageApiResponse apiResponseLocalVar, long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="rebuildServerFromImageRequest"></param>
        private void OnErrorRebuildServerFromImageDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRebuildServerFromImage(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, rebuildServerFromImageRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="rebuildServerFromImageRequest"></param>
        partial void OnErrorRebuildServerFromImage(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest);

        /// <summary>
        /// Rebuild a Server from an Image Rebuilds a Server overwriting its disk with the content of an Image, thereby **destroying all data** on the target Server  The Image can either be one you have created earlier (&#x60;backup&#x60; or &#x60;snapshot&#x60; Image) or it can be a completely fresh &#x60;system&#x60; Image provided by us. You can get a list of all available Images with &#x60;GET /images&#x60;.  Your Server will automatically be powered off before the rebuild command executes. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="rebuildServerFromImageRequest">To select which Image to rebuild from you can either pass an ID or a name as the &#x60;image&#x60; argument. Passing a name only works for &#x60;system&#x60; Images since the other Image types do not have a name set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRebuildServerFromImageApiResponse"/>&gt;</returns>
        public async Task<IRebuildServerFromImageApiResponse?> RebuildServerFromImageOrDefaultAsync(long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RebuildServerFromImageAsync(id, rebuildServerFromImageRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Rebuild a Server from an Image Rebuilds a Server overwriting its disk with the content of an Image, thereby **destroying all data** on the target Server  The Image can either be one you have created earlier (&#x60;backup&#x60; or &#x60;snapshot&#x60; Image) or it can be a completely fresh &#x60;system&#x60; Image provided by us. You can get a list of all available Images with &#x60;GET /images&#x60;.  Your Server will automatically be powered off before the rebuild command executes. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="rebuildServerFromImageRequest">To select which Image to rebuild from you can either pass an ID or a name as the &#x60;image&#x60; argument. Passing a name only works for &#x60;system&#x60; Images since the other Image types do not have a name set. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRebuildServerFromImageApiResponse"/>&gt;</returns>
        public async Task<IRebuildServerFromImageApiResponse> RebuildServerFromImageAsync(long id, Option<RebuildServerFromImageRequest> rebuildServerFromImageRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateRebuildServerFromImage(rebuildServerFromImageRequest);

                FormatRebuildServerFromImage(ref id, rebuildServerFromImageRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/rebuild"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/rebuild");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (rebuildServerFromImageRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (rebuildServerFromImageRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(rebuildServerFromImageRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RebuildServerFromImageApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RebuildServerFromImageApiResponse>();

                        RebuildServerFromImageApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/rebuild", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRebuildServerFromImageDefaultImplementation(apiResponseLocalVar, id, rebuildServerFromImageRequest);

                        Events.ExecuteOnRebuildServerFromImage(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRebuildServerFromImageDefaultImplementation(e, "/servers/{id}/actions/rebuild", uriBuilderLocalVar.Path, id, rebuildServerFromImageRequest);
                Events.ExecuteOnErrorRebuildServerFromImage(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RebuildServerFromImageApiResponse"/>
        /// </summary>
        public partial class RebuildServerFromImageApiResponse : Hetzner.Cloud.Client.ApiResponse, IRebuildServerFromImageApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RebuildServerFromImageApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RebuildServerFromImageApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RebuildServerFromImageApiResponse(ILogger<RebuildServerFromImageApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.RebuildServerFromImageResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.RebuildServerFromImageResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.RebuildServerFromImageResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRemoveFromPlacementGroup(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterRemoveFromPlacementGroupDefaultImplementation(IRemoveFromPlacementGroupApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterRemoveFromPlacementGroup(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterRemoveFromPlacementGroup(ref bool suppressDefaultLog, IRemoveFromPlacementGroupApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorRemoveFromPlacementGroupDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRemoveFromPlacementGroup(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorRemoveFromPlacementGroup(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Remove from Placement Group Removes a Server from a Placement Group. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveFromPlacementGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveFromPlacementGroupApiResponse?> RemoveFromPlacementGroupOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RemoveFromPlacementGroupAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Remove from Placement Group Removes a Server from a Placement Group. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRemoveFromPlacementGroupApiResponse"/>&gt;</returns>
        public async Task<IRemoveFromPlacementGroupApiResponse> RemoveFromPlacementGroupAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRemoveFromPlacementGroup(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/remove_from_placement_group"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/remove_from_placement_group");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RemoveFromPlacementGroupApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RemoveFromPlacementGroupApiResponse>();

                        RemoveFromPlacementGroupApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/remove_from_placement_group", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRemoveFromPlacementGroupDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnRemoveFromPlacementGroup(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRemoveFromPlacementGroupDefaultImplementation(e, "/servers/{id}/actions/remove_from_placement_group", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorRemoveFromPlacementGroup(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RemoveFromPlacementGroupApiResponse"/>
        /// </summary>
        public partial class RemoveFromPlacementGroupApiResponse : Hetzner.Cloud.Client.ApiResponse, IRemoveFromPlacementGroupApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RemoveFromPlacementGroupApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RemoveFromPlacementGroupApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RemoveFromPlacementGroupApiResponse(ILogger<RemoveFromPlacementGroupApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.RemoveFromPlacementGroupResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.RemoveFromPlacementGroupResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.RemoveFromPlacementGroupResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReplaceServer(ref long id, Option<ReplaceServerRequest> replaceServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="replaceServerRequest"></param>
        /// <returns></returns>
        private void ValidateReplaceServer(Option<ReplaceServerRequest> replaceServerRequest)
        {
            if (replaceServerRequest.IsSet && replaceServerRequest.Value == null)
                throw new ArgumentNullException(nameof(replaceServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceServerRequest"></param>
        private void AfterReplaceServerDefaultImplementation(IReplaceServerApiResponse apiResponseLocalVar, long id, Option<ReplaceServerRequest> replaceServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterReplaceServer(ref suppressDefaultLog, apiResponseLocalVar, id, replaceServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceServerRequest"></param>
        partial void AfterReplaceServer(ref bool suppressDefaultLog, IReplaceServerApiResponse apiResponseLocalVar, long id, Option<ReplaceServerRequest> replaceServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceServerRequest"></param>
        private void OnErrorReplaceServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceServerRequest> replaceServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorReplaceServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, replaceServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceServerRequest"></param>
        partial void OnErrorReplaceServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceServerRequest> replaceServerRequest);

        /// <summary>
        /// Update a Server Updates a Server. You can update a Server’s name and a Server’s labels. Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes). Also note that when updating labels, the Server’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="replaceServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceServerApiResponse"/>&gt;</returns>
        public async Task<IReplaceServerApiResponse?> ReplaceServerOrDefaultAsync(long id, Option<ReplaceServerRequest> replaceServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReplaceServerAsync(id, replaceServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update a Server Updates a Server. You can update a Server’s name and a Server’s labels. Please note that Server names must be unique per Project and valid hostnames as per RFC 1123 (i.e. may only contain letters, digits, periods, and dashes). Also note that when updating labels, the Server’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="replaceServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceServerApiResponse"/>&gt;</returns>
        public async Task<IReplaceServerApiResponse> ReplaceServerAsync(long id, Option<ReplaceServerRequest> replaceServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateReplaceServer(replaceServerRequest);

                FormatReplaceServer(ref id, replaceServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (replaceServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (replaceServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(replaceServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ReplaceServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReplaceServerApiResponse>();

                        ReplaceServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReplaceServerDefaultImplementation(apiResponseLocalVar, id, replaceServerRequest);

                        Events.ExecuteOnReplaceServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReplaceServerDefaultImplementation(e, "/servers/{id}", uriBuilderLocalVar.Path, id, replaceServerRequest);
                Events.ExecuteOnErrorReplaceServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReplaceServerApiResponse"/>
        /// </summary>
        public partial class ReplaceServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IReplaceServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReplaceServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReplaceServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReplaceServerApiResponse(ILogger<ReplaceServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ReplaceServerResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ReplaceServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ReplaceServerResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRequestConsoleForServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterRequestConsoleForServerDefaultImplementation(IRequestConsoleForServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterRequestConsoleForServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterRequestConsoleForServer(ref bool suppressDefaultLog, IRequestConsoleForServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorRequestConsoleForServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRequestConsoleForServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorRequestConsoleForServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Request Console for a Server Requests credentials for remote access via VNC over websocket to keyboard, monitor, and mouse for a Server. The provided URL is valid for 1 minute, after this period a new url needs to be created to connect to the Server. How long the connection is open after the initial connect is not subject to this timeout.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRequestConsoleForServerApiResponse"/>&gt;</returns>
        public async Task<IRequestConsoleForServerApiResponse?> RequestConsoleForServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RequestConsoleForServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Request Console for a Server Requests credentials for remote access via VNC over websocket to keyboard, monitor, and mouse for a Server. The provided URL is valid for 1 minute, after this period a new url needs to be created to connect to the Server. How long the connection is open after the initial connect is not subject to this timeout.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRequestConsoleForServerApiResponse"/>&gt;</returns>
        public async Task<IRequestConsoleForServerApiResponse> RequestConsoleForServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRequestConsoleForServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/request_console"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/request_console");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<RequestConsoleForServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RequestConsoleForServerApiResponse>();

                        RequestConsoleForServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/request_console", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterRequestConsoleForServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnRequestConsoleForServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRequestConsoleForServerDefaultImplementation(e, "/servers/{id}/actions/request_console", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorRequestConsoleForServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RequestConsoleForServerApiResponse"/>
        /// </summary>
        public partial class RequestConsoleForServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IRequestConsoleForServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RequestConsoleForServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RequestConsoleForServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RequestConsoleForServerApiResponse(ILogger<RequestConsoleForServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.RequestConsoleForServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.RequestConsoleForServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.RequestConsoleForServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatResetRootPasswordOfServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterResetRootPasswordOfServerDefaultImplementation(IResetRootPasswordOfServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterResetRootPasswordOfServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterResetRootPasswordOfServer(ref bool suppressDefaultLog, IResetRootPasswordOfServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorResetRootPasswordOfServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorResetRootPasswordOfServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorResetRootPasswordOfServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Reset root Password of a Server Resets the root password. Only works for Linux systems that are running the qemu guest agent. Server must be powered on (status &#x60;running&#x60;) in order for this operation to succeed.  This will generate a new password for this Server and return it.  If this does not succeed you can use the rescue system to netboot the Server and manually change your Server password by hand. 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetRootPasswordOfServerApiResponse"/>&gt;</returns>
        public async Task<IResetRootPasswordOfServerApiResponse?> ResetRootPasswordOfServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ResetRootPasswordOfServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Reset root Password of a Server Resets the root password. Only works for Linux systems that are running the qemu guest agent. Server must be powered on (status &#x60;running&#x60;) in order for this operation to succeed.  This will generate a new password for this Server and return it.  If this does not succeed you can use the rescue system to netboot the Server and manually change your Server password by hand. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetRootPasswordOfServerApiResponse"/>&gt;</returns>
        public async Task<IResetRootPasswordOfServerApiResponse> ResetRootPasswordOfServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatResetRootPasswordOfServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/reset_password"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/reset_password");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ResetRootPasswordOfServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ResetRootPasswordOfServerApiResponse>();

                        ResetRootPasswordOfServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/reset_password", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterResetRootPasswordOfServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnResetRootPasswordOfServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorResetRootPasswordOfServerDefaultImplementation(e, "/servers/{id}/actions/reset_password", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorResetRootPasswordOfServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ResetRootPasswordOfServerApiResponse"/>
        /// </summary>
        public partial class ResetRootPasswordOfServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IResetRootPasswordOfServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ResetRootPasswordOfServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ResetRootPasswordOfServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ResetRootPasswordOfServerApiResponse(ILogger<ResetRootPasswordOfServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ResetRootPasswordOfServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ResetRootPasswordOfServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ResetRootPasswordOfServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatResetServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterResetServerDefaultImplementation(IResetServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterResetServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterResetServer(ref bool suppressDefaultLog, IResetServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorResetServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorResetServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorResetServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Reset a Server Cuts power to a Server and starts it again. This forcefully stops it without giving the Server operating system time to gracefully stop. This may lead to data loss, it’s equivalent to pulling the power cord and plugging it in again. Reset should only be used when reboot does not work.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetServerApiResponse"/>&gt;</returns>
        public async Task<IResetServerApiResponse?> ResetServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ResetServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Reset a Server Cuts power to a Server and starts it again. This forcefully stops it without giving the Server operating system time to gracefully stop. This may lead to data loss, it’s equivalent to pulling the power cord and plugging it in again. Reset should only be used when reboot does not work.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResetServerApiResponse"/>&gt;</returns>
        public async Task<IResetServerApiResponse> ResetServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatResetServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/reset"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/reset");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ResetServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ResetServerApiResponse>();

                        ResetServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/reset", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterResetServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnResetServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorResetServerDefaultImplementation(e, "/servers/{id}/actions/reset", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorResetServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ResetServerApiResponse"/>
        /// </summary>
        public partial class ResetServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IResetServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ResetServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ResetServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ResetServerApiResponse(ILogger<ResetServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ResetServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ResetServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ResetServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatShutdownServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterShutdownServerDefaultImplementation(IShutdownServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterShutdownServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterShutdownServer(ref bool suppressDefaultLog, IShutdownServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorShutdownServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorShutdownServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorShutdownServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Shutdown a Server Shuts down a Server gracefully by sending an ACPI shutdown request. The Server operating system must support ACPI and react to the request, otherwise the Server will not shut down. Please note that the &#x60;action&#x60; status in this case only reflects whether the action was sent to the server. It does not mean that the server actually shut down successfully. If you need to ensure that the server is off, use the &#x60;poweroff&#x60; action 
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IShutdownServerApiResponse"/>&gt;</returns>
        public async Task<IShutdownServerApiResponse?> ShutdownServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ShutdownServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Shutdown a Server Shuts down a Server gracefully by sending an ACPI shutdown request. The Server operating system must support ACPI and react to the request, otherwise the Server will not shut down. Please note that the &#x60;action&#x60; status in this case only reflects whether the action was sent to the server. It does not mean that the server actually shut down successfully. If you need to ensure that the server is off, use the &#x60;poweroff&#x60; action 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IShutdownServerApiResponse"/>&gt;</returns>
        public async Task<IShutdownServerApiResponse> ShutdownServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatShutdownServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/shutdown"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/shutdown");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ShutdownServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ShutdownServerApiResponse>();

                        ShutdownServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/shutdown", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterShutdownServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnShutdownServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorShutdownServerDefaultImplementation(e, "/servers/{id}/actions/shutdown", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorShutdownServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ShutdownServerApiResponse"/>
        /// </summary>
        public partial class ShutdownServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IShutdownServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ShutdownServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ShutdownServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ShutdownServerApiResponse(ILogger<ShutdownServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ShutdownServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ShutdownServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ShutdownServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSoftRebootServer(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterSoftRebootServerDefaultImplementation(ISoftRebootServerApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterSoftRebootServer(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterSoftRebootServer(ref bool suppressDefaultLog, ISoftRebootServerApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorSoftRebootServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSoftRebootServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorSoftRebootServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Soft-reboot a Server Reboots a Server gracefully by sending an ACPI request. The Server operating system must support ACPI and react to the request, otherwise the Server will not reboot.
        /// </summary>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISoftRebootServerApiResponse"/>&gt;</returns>
        public async Task<ISoftRebootServerApiResponse?> SoftRebootServerOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SoftRebootServerAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Soft-reboot a Server Reboots a Server gracefully by sending an ACPI request. The Server operating system must support ACPI and react to the request, otherwise the Server will not reboot.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Server.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISoftRebootServerApiResponse"/>&gt;</returns>
        public async Task<ISoftRebootServerApiResponse> SoftRebootServerAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatSoftRebootServer(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/servers/{id}/actions/reboot"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/servers/{id}/actions/reboot");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<SoftRebootServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SoftRebootServerApiResponse>();

                        SoftRebootServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/servers/{id}/actions/reboot", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterSoftRebootServerDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnSoftRebootServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSoftRebootServerDefaultImplementation(e, "/servers/{id}/actions/reboot", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorSoftRebootServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SoftRebootServerApiResponse"/>
        /// </summary>
        public partial class SoftRebootServerApiResponse : Hetzner.Cloud.Client.ApiResponse, ISoftRebootServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SoftRebootServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SoftRebootServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SoftRebootServerApiResponse(ILogger<SoftRebootServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.SoftRebootServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.SoftRebootServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.SoftRebootServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
