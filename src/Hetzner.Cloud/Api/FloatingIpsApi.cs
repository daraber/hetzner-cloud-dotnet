// <auto-generated>
/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.22.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Hetzner.Cloud.Client;
using Hetzner.Cloud.Model;
using System.Diagnostics.CodeAnalysis;

namespace Hetzner.Cloud.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IFloatingIpsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        FloatingIpsApiEvents Events { get; }

        /// <summary>
        /// Assign a Floating IP to a Server
        /// </summary>
        /// <remarks>
        /// Assigns a [Floating IP](#floating-ips) to a [Server](#servers).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="assignFloatingIpToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAssignFloatingIpToServerApiResponse"/>&gt;</returns>
        Task<IAssignFloatingIpToServerApiResponse> AssignFloatingIpToServerAsync(long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Assign a Floating IP to a Server
        /// </summary>
        /// <remarks>
        /// Assigns a [Floating IP](#floating-ips) to a [Server](#servers).
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="assignFloatingIpToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAssignFloatingIpToServerApiResponse"/>?&gt;</returns>
        Task<IAssignFloatingIpToServerApiResponse?> AssignFloatingIpToServerOrDefaultAsync(long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change Floating IP Protection
        /// </summary>
        /// <remarks>
        /// Changes the protection settings configured for the [Floating IP](#floating-ips).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeFloatingIpProtectionApiResponse"/>&gt;</returns>
        Task<IChangeFloatingIpProtectionApiResponse> ChangeFloatingIpProtectionAsync(long id, Option<Protection> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change Floating IP Protection
        /// </summary>
        /// <remarks>
        /// Changes the protection settings configured for the [Floating IP](#floating-ips).
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeFloatingIpProtectionApiResponse"/>?&gt;</returns>
        Task<IChangeFloatingIpProtectionApiResponse?> ChangeFloatingIpProtectionOrDefaultAsync(long id, Option<Protection> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change reverse DNS records for a Floating IP
        /// </summary>
        /// <remarks>
        /// Change the reverse DNS records for this [Floating IP](#floating-ips).  Allows to modify the PTR records set for the IP address. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body">The &#x60;ip&#x60; attributes specifies for which IP address the record is set. For IPv4 addresses this must be the exact address of the [Floating IP](#floating-ips). For IPv6 addresses this must be a single address within the &#x60;/64&#x60; subnet of the [Floating IP](#floating-ips).  The &#x60;dns_ptr&#x60; attribute specifies the hostname used for the IP address.  For IPv6 [Floating IPs](#floating-ips) up to 100 entries can be created.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsRecordsForFloatingIpApiResponse"/>&gt;</returns>
        Task<IChangeReverseDnsRecordsForFloatingIpApiResponse> ChangeReverseDnsRecordsForFloatingIpAsync(long id, Option<DnsPtr> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change reverse DNS records for a Floating IP
        /// </summary>
        /// <remarks>
        /// Change the reverse DNS records for this [Floating IP](#floating-ips).  Allows to modify the PTR records set for the IP address. 
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body">The &#x60;ip&#x60; attributes specifies for which IP address the record is set. For IPv4 addresses this must be the exact address of the [Floating IP](#floating-ips). For IPv6 addresses this must be a single address within the &#x60;/64&#x60; subnet of the [Floating IP](#floating-ips).  The &#x60;dns_ptr&#x60; attribute specifies the hostname used for the IP address.  For IPv6 [Floating IPs](#floating-ips) up to 100 entries can be created.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsRecordsForFloatingIpApiResponse"/>?&gt;</returns>
        Task<IChangeReverseDnsRecordsForFloatingIpApiResponse?> ChangeReverseDnsRecordsForFloatingIpOrDefaultAsync(long id, Option<DnsPtr> body = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Floating IP
        /// </summary>
        /// <remarks>
        /// Create a [Floating IP](#floating-ips).  Provide the &#x60;server&#x60; attribute to assign the [Floating IP](#floating-ips) to that server or provide a &#x60;home_location&#x60; to locate the [Floating IP](#floating-ips) at. Note that the [Floating IP](#floating-ips) can be assigned to a [Server](#servers) in any [Location](#locations) later on. For optimal routing it is advised to use the [Floating IP](#floating-ips) in the same [Location](#locations) it was created in. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createFloatingIpRequest">The &#x60;type&#x60; argument is required while &#x60;home_location&#x60; and &#x60;server&#x60; are mutually exclusive. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateFloatingIpApiResponse"/>&gt;</returns>
        Task<ICreateFloatingIpApiResponse> CreateFloatingIpAsync(Option<CreateFloatingIpRequest> createFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Floating IP
        /// </summary>
        /// <remarks>
        /// Create a [Floating IP](#floating-ips).  Provide the &#x60;server&#x60; attribute to assign the [Floating IP](#floating-ips) to that server or provide a &#x60;home_location&#x60; to locate the [Floating IP](#floating-ips) at. Note that the [Floating IP](#floating-ips) can be assigned to a [Server](#servers) in any [Location](#locations) later on. For optimal routing it is advised to use the [Floating IP](#floating-ips) in the same [Location](#locations) it was created in. 
        /// </remarks>
        /// <param name="createFloatingIpRequest">The &#x60;type&#x60; argument is required while &#x60;home_location&#x60; and &#x60;server&#x60; are mutually exclusive. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateFloatingIpApiResponse"/>?&gt;</returns>
        Task<ICreateFloatingIpApiResponse?> CreateFloatingIpOrDefaultAsync(Option<CreateFloatingIpRequest> createFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Floating IP
        /// </summary>
        /// <remarks>
        /// Deletes a [Floating IP](#floating-ips).  If the IP is assigned to a resource it will be unassigned. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteFloatingIpApiResponse"/>&gt;</returns>
        Task<IDeleteFloatingIpApiResponse> DeleteFloatingIpAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Floating IP
        /// </summary>
        /// <remarks>
        /// Deletes a [Floating IP](#floating-ips).  If the IP is assigned to a resource it will be unassigned. 
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteFloatingIpApiResponse"/>?&gt;</returns>
        Task<IDeleteFloatingIpApiResponse?> DeleteFloatingIpOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Floating IP
        /// </summary>
        /// <remarks>
        /// Returns a specific [Action](#actions) for a [Floating IP](#floating-ips).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForFloatingIpApiResponse"/>&gt;</returns>
        Task<IGetActionForFloatingIpApiResponse> GetActionForFloatingIpAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Floating IP
        /// </summary>
        /// <remarks>
        /// Returns a specific [Action](#actions) for a [Floating IP](#floating-ips).
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForFloatingIpApiResponse"/>?&gt;</returns>
        Task<IGetActionForFloatingIpApiResponse?> GetActionForFloatingIpOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Floating IP
        /// </summary>
        /// <remarks>
        /// Returns a single [Floating IP](#floating-ips).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpApiResponse"/>&gt;</returns>
        Task<IGetFloatingIpApiResponse> GetFloatingIpAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Floating IP
        /// </summary>
        /// <remarks>
        /// Returns a single [Floating IP](#floating-ips).
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpApiResponse"/>?&gt;</returns>
        Task<IGetFloatingIpApiResponse?> GetFloatingIpOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a single [Action](#actions).
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpActionApiResponse"/>&gt;</returns>
        Task<IGetFloatingIpActionApiResponse> GetFloatingIpActionAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a single [Action](#actions).
        /// </remarks>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpActionApiResponse"/>?&gt;</returns>
        Task<IGetFloatingIpActionApiResponse?> GetFloatingIpActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Floating IP
        /// </summary>
        /// <remarks>
        /// Lists [Actions](#actions) for a [Floating IP](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForFloatingIpApiResponse"/>&gt;</returns>
        Task<IListActionsForFloatingIpApiResponse> ListActionsForFloatingIpAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Floating IP
        /// </summary>
        /// <remarks>
        /// Lists [Actions](#actions) for a [Floating IP](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForFloatingIpApiResponse"/>?&gt;</returns>
        Task<IListActionsForFloatingIpApiResponse?> ListActionsForFloatingIpOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Lists multiple [Actions](#actions).  Use the provided URI parameters to modify the result. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpActionsApiResponse"/>&gt;</returns>
        Task<IListFloatingIpActionsApiResponse> ListFloatingIpActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Lists multiple [Actions](#actions).  Use the provided URI parameters to modify the result. 
        /// </remarks>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpActionsApiResponse"/>?&gt;</returns>
        Task<IListFloatingIpActionsApiResponse?> ListFloatingIpActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Floating IPs
        /// </summary>
        /// <remarks>
        /// List multiple [Floating IPs](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpsApiResponse"/>&gt;</returns>
        Task<IListFloatingIpsApiResponse> ListFloatingIpsAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Floating IPs
        /// </summary>
        /// <remarks>
        /// List multiple [Floating IPs](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </remarks>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpsApiResponse"/>?&gt;</returns>
        Task<IListFloatingIpsApiResponse?> ListFloatingIpsOrDefaultAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Floating IP
        /// </summary>
        /// <remarks>
        /// Update the description or [Labels](#labels) of a [Floating IP](#floating-ips). Note that when updating [Labels](#labels), the [Floating IPs](#floating-ips) current set of [Labels](#labels) will be replaced with the [Labels](#labels) provided with the request. So, for example, if you want to add a new [Label](#labels), you have to provide all existing [Labels](#labels) plus the new [Label](#labels) in the request body.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="replaceFloatingIpRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceFloatingIpApiResponse"/>&gt;</returns>
        Task<IReplaceFloatingIpApiResponse> ReplaceFloatingIpAsync(long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Floating IP
        /// </summary>
        /// <remarks>
        /// Update the description or [Labels](#labels) of a [Floating IP](#floating-ips). Note that when updating [Labels](#labels), the [Floating IPs](#floating-ips) current set of [Labels](#labels) will be replaced with the [Labels](#labels) provided with the request. So, for example, if you want to add a new [Label](#labels), you have to provide all existing [Labels](#labels) plus the new [Label](#labels) in the request body.
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="replaceFloatingIpRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceFloatingIpApiResponse"/>?&gt;</returns>
        Task<IReplaceFloatingIpApiResponse?> ReplaceFloatingIpOrDefaultAsync(long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unassign a Floating IP
        /// </summary>
        /// <remarks>
        /// Unassigns a [Floating IP](#floating-ips).  Results in the IP being unreachable. Can be assigned to another resource again. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnassignFloatingIpApiResponse"/>&gt;</returns>
        Task<IUnassignFloatingIpApiResponse> UnassignFloatingIpAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Unassign a Floating IP
        /// </summary>
        /// <remarks>
        /// Unassigns a [Floating IP](#floating-ips).  Results in the IP being unreachable. Can be assigned to another resource again. 
        /// </remarks>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnassignFloatingIpApiResponse"/>?&gt;</returns>
        Task<IUnassignFloatingIpApiResponse?> UnassignFloatingIpOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAssignFloatingIpToServerApiResponse"/>
    /// </summary>
    public interface IAssignFloatingIpToServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.AssignFloatingIpToServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeFloatingIpProtectionApiResponse"/>
    /// </summary>
    public interface IChangeFloatingIpProtectionApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeFloatingIpProtectionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeReverseDnsRecordsForFloatingIpApiResponse"/>
    /// </summary>
    public interface IChangeReverseDnsRecordsForFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeReverseDnsRecordsForFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateFloatingIpApiResponse"/>
    /// </summary>
    public interface ICreateFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.CreateFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteFloatingIpApiResponse"/>
    /// </summary>
    public interface IDeleteFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IGetActionForFloatingIpApiResponse"/>
    /// </summary>
    public interface IGetActionForFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionForFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetFloatingIpApiResponse"/>
    /// </summary>
    public interface IGetFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetFloatingIpActionApiResponse"/>
    /// </summary>
    public interface IGetFloatingIpActionApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListActionsForFloatingIpApiResponse"/>
    /// </summary>
    public interface IListActionsForFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsForFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListFloatingIpActionsApiResponse"/>
    /// </summary>
    public interface IListFloatingIpActionsApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListFloatingIpsApiResponse"/>
    /// </summary>
    public interface IListFloatingIpsApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListFloatingIpsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IReplaceFloatingIpApiResponse"/>
    /// </summary>
    public interface IReplaceFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ReplaceFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IUnassignFloatingIpApiResponse"/>
    /// </summary>
    public interface IUnassignFloatingIpApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.UnassignFloatingIpResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class FloatingIpsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAssignFloatingIpToServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAssignFloatingIpToServer;

        internal void ExecuteOnAssignFloatingIpToServer(FloatingIpsApi.AssignFloatingIpToServerApiResponse apiResponse)
        {
            OnAssignFloatingIpToServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAssignFloatingIpToServer(Exception exception)
        {
            OnErrorAssignFloatingIpToServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeFloatingIpProtection;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeFloatingIpProtection;

        internal void ExecuteOnChangeFloatingIpProtection(FloatingIpsApi.ChangeFloatingIpProtectionApiResponse apiResponse)
        {
            OnChangeFloatingIpProtection?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeFloatingIpProtection(Exception exception)
        {
            OnErrorChangeFloatingIpProtection?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeReverseDnsRecordsForFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeReverseDnsRecordsForFloatingIp;

        internal void ExecuteOnChangeReverseDnsRecordsForFloatingIp(FloatingIpsApi.ChangeReverseDnsRecordsForFloatingIpApiResponse apiResponse)
        {
            OnChangeReverseDnsRecordsForFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeReverseDnsRecordsForFloatingIp(Exception exception)
        {
            OnErrorChangeReverseDnsRecordsForFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateFloatingIp;

        internal void ExecuteOnCreateFloatingIp(FloatingIpsApi.CreateFloatingIpApiResponse apiResponse)
        {
            OnCreateFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateFloatingIp(Exception exception)
        {
            OnErrorCreateFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteFloatingIp;

        internal void ExecuteOnDeleteFloatingIp(FloatingIpsApi.DeleteFloatingIpApiResponse apiResponse)
        {
            OnDeleteFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteFloatingIp(Exception exception)
        {
            OnErrorDeleteFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetActionForFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetActionForFloatingIp;

        internal void ExecuteOnGetActionForFloatingIp(FloatingIpsApi.GetActionForFloatingIpApiResponse apiResponse)
        {
            OnGetActionForFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetActionForFloatingIp(Exception exception)
        {
            OnErrorGetActionForFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFloatingIp;

        internal void ExecuteOnGetFloatingIp(FloatingIpsApi.GetFloatingIpApiResponse apiResponse)
        {
            OnGetFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFloatingIp(Exception exception)
        {
            OnErrorGetFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFloatingIpAction;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFloatingIpAction;

        internal void ExecuteOnGetFloatingIpAction(FloatingIpsApi.GetFloatingIpActionApiResponse apiResponse)
        {
            OnGetFloatingIpAction?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFloatingIpAction(Exception exception)
        {
            OnErrorGetFloatingIpAction?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListActionsForFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListActionsForFloatingIp;

        internal void ExecuteOnListActionsForFloatingIp(FloatingIpsApi.ListActionsForFloatingIpApiResponse apiResponse)
        {
            OnListActionsForFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListActionsForFloatingIp(Exception exception)
        {
            OnErrorListActionsForFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListFloatingIpActions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListFloatingIpActions;

        internal void ExecuteOnListFloatingIpActions(FloatingIpsApi.ListFloatingIpActionsApiResponse apiResponse)
        {
            OnListFloatingIpActions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListFloatingIpActions(Exception exception)
        {
            OnErrorListFloatingIpActions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListFloatingIps;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListFloatingIps;

        internal void ExecuteOnListFloatingIps(FloatingIpsApi.ListFloatingIpsApiResponse apiResponse)
        {
            OnListFloatingIps?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListFloatingIps(Exception exception)
        {
            OnErrorListFloatingIps?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnReplaceFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorReplaceFloatingIp;

        internal void ExecuteOnReplaceFloatingIp(FloatingIpsApi.ReplaceFloatingIpApiResponse apiResponse)
        {
            OnReplaceFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReplaceFloatingIp(Exception exception)
        {
            OnErrorReplaceFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUnassignFloatingIp;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUnassignFloatingIp;

        internal void ExecuteOnUnassignFloatingIp(FloatingIpsApi.UnassignFloatingIpApiResponse apiResponse)
        {
            OnUnassignFloatingIp?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUnassignFloatingIp(Exception exception)
        {
            OnErrorUnassignFloatingIp?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class FloatingIpsApi : IFloatingIpsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<FloatingIpsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public FloatingIpsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="FloatingIpsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public FloatingIpsApi(ILogger<FloatingIpsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, FloatingIpsApiEvents floatingIpsApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<FloatingIpsApi>();
            HttpClient = httpClient;
            Events = floatingIpsApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatAssignFloatingIpToServer(ref long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="assignFloatingIpToServerRequest"></param>
        /// <returns></returns>
        private void ValidateAssignFloatingIpToServer(Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest)
        {
            if (assignFloatingIpToServerRequest.IsSet && assignFloatingIpToServerRequest.Value == null)
                throw new ArgumentNullException(nameof(assignFloatingIpToServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="assignFloatingIpToServerRequest"></param>
        private void AfterAssignFloatingIpToServerDefaultImplementation(IAssignFloatingIpToServerApiResponse apiResponseLocalVar, long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterAssignFloatingIpToServer(ref suppressDefaultLog, apiResponseLocalVar, id, assignFloatingIpToServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="assignFloatingIpToServerRequest"></param>
        partial void AfterAssignFloatingIpToServer(ref bool suppressDefaultLog, IAssignFloatingIpToServerApiResponse apiResponseLocalVar, long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="assignFloatingIpToServerRequest"></param>
        private void OnErrorAssignFloatingIpToServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAssignFloatingIpToServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, assignFloatingIpToServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="assignFloatingIpToServerRequest"></param>
        partial void OnErrorAssignFloatingIpToServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest);

        /// <summary>
        /// Assign a Floating IP to a Server Assigns a [Floating IP](#floating-ips) to a [Server](#servers).
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="assignFloatingIpToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAssignFloatingIpToServerApiResponse"/>&gt;</returns>
        public async Task<IAssignFloatingIpToServerApiResponse?> AssignFloatingIpToServerOrDefaultAsync(long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AssignFloatingIpToServerAsync(id, assignFloatingIpToServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Assign a Floating IP to a Server Assigns a [Floating IP](#floating-ips) to a [Server](#servers).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="assignFloatingIpToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAssignFloatingIpToServerApiResponse"/>&gt;</returns>
        public async Task<IAssignFloatingIpToServerApiResponse> AssignFloatingIpToServerAsync(long id, Option<AssignFloatingIpToServerRequest> assignFloatingIpToServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAssignFloatingIpToServer(assignFloatingIpToServerRequest);

                FormatAssignFloatingIpToServer(ref id, assignFloatingIpToServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}/actions/assign"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}/actions/assign");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (assignFloatingIpToServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (assignFloatingIpToServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(assignFloatingIpToServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AssignFloatingIpToServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AssignFloatingIpToServerApiResponse>();

                        AssignFloatingIpToServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}/actions/assign", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAssignFloatingIpToServerDefaultImplementation(apiResponseLocalVar, id, assignFloatingIpToServerRequest);

                        Events.ExecuteOnAssignFloatingIpToServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAssignFloatingIpToServerDefaultImplementation(e, "/floating_ips/{id}/actions/assign", uriBuilderLocalVar.Path, id, assignFloatingIpToServerRequest);
                Events.ExecuteOnErrorAssignFloatingIpToServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AssignFloatingIpToServerApiResponse"/>
        /// </summary>
        public partial class AssignFloatingIpToServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IAssignFloatingIpToServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AssignFloatingIpToServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AssignFloatingIpToServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AssignFloatingIpToServerApiResponse(ILogger<AssignFloatingIpToServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.AssignFloatingIpToServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.AssignFloatingIpToServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.AssignFloatingIpToServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeFloatingIpProtection(ref long id, ref Option<Protection> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateChangeFloatingIpProtection(Option<Protection> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterChangeFloatingIpProtectionDefaultImplementation(IChangeFloatingIpProtectionApiResponse apiResponseLocalVar, long id, Option<Protection> body)
        {
            bool suppressDefaultLog = false;
            AfterChangeFloatingIpProtection(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterChangeFloatingIpProtection(ref bool suppressDefaultLog, IChangeFloatingIpProtectionApiResponse apiResponseLocalVar, long id, Option<Protection> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorChangeFloatingIpProtectionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Protection> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeFloatingIpProtection(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorChangeFloatingIpProtection(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<Protection> body);

        /// <summary>
        /// Change Floating IP Protection Changes the protection settings configured for the [Floating IP](#floating-ips).
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeFloatingIpProtectionApiResponse"/>&gt;</returns>
        public async Task<IChangeFloatingIpProtectionApiResponse?> ChangeFloatingIpProtectionOrDefaultAsync(long id, Option<Protection> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeFloatingIpProtectionAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change Floating IP Protection Changes the protection settings configured for the [Floating IP](#floating-ips).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeFloatingIpProtectionApiResponse"/>&gt;</returns>
        public async Task<IChangeFloatingIpProtectionApiResponse> ChangeFloatingIpProtectionAsync(long id, Option<Protection> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeFloatingIpProtection(body);

                FormatChangeFloatingIpProtection(ref id, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}/actions/change_protection"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}/actions/change_protection");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeFloatingIpProtectionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeFloatingIpProtectionApiResponse>();

                        ChangeFloatingIpProtectionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}/actions/change_protection", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeFloatingIpProtectionDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnChangeFloatingIpProtection(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeFloatingIpProtectionDefaultImplementation(e, "/floating_ips/{id}/actions/change_protection", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorChangeFloatingIpProtection(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeFloatingIpProtectionApiResponse"/>
        /// </summary>
        public partial class ChangeFloatingIpProtectionApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeFloatingIpProtectionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeFloatingIpProtectionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeFloatingIpProtectionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeFloatingIpProtectionApiResponse(ILogger<ChangeFloatingIpProtectionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeFloatingIpProtectionResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeFloatingIpProtectionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeFloatingIpProtectionResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeReverseDnsRecordsForFloatingIp(ref long id, ref Option<DnsPtr> body);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="body"></param>
        /// <returns></returns>
        private void ValidateChangeReverseDnsRecordsForFloatingIp(Option<DnsPtr> body)
        {
            if (body.IsSet && body.Value == null)
                throw new ArgumentNullException(nameof(body));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void AfterChangeReverseDnsRecordsForFloatingIpDefaultImplementation(IChangeReverseDnsRecordsForFloatingIpApiResponse apiResponseLocalVar, long id, Option<DnsPtr> body)
        {
            bool suppressDefaultLog = false;
            AfterChangeReverseDnsRecordsForFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id, body);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void AfterChangeReverseDnsRecordsForFloatingIp(ref bool suppressDefaultLog, IChangeReverseDnsRecordsForFloatingIpApiResponse apiResponseLocalVar, long id, Option<DnsPtr> body);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        private void OnErrorChangeReverseDnsRecordsForFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<DnsPtr> body)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeReverseDnsRecordsForFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, body);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="body"></param>
        partial void OnErrorChangeReverseDnsRecordsForFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<DnsPtr> body);

        /// <summary>
        /// Change reverse DNS records for a Floating IP Change the reverse DNS records for this [Floating IP](#floating-ips).  Allows to modify the PTR records set for the IP address. 
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body">The &#x60;ip&#x60; attributes specifies for which IP address the record is set. For IPv4 addresses this must be the exact address of the [Floating IP](#floating-ips). For IPv6 addresses this must be a single address within the &#x60;/64&#x60; subnet of the [Floating IP](#floating-ips).  The &#x60;dns_ptr&#x60; attribute specifies the hostname used for the IP address.  For IPv6 [Floating IPs](#floating-ips) up to 100 entries can be created.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsRecordsForFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IChangeReverseDnsRecordsForFloatingIpApiResponse?> ChangeReverseDnsRecordsForFloatingIpOrDefaultAsync(long id, Option<DnsPtr> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeReverseDnsRecordsForFloatingIpAsync(id, body, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change reverse DNS records for a Floating IP Change the reverse DNS records for this [Floating IP](#floating-ips).  Allows to modify the PTR records set for the IP address. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="body">The &#x60;ip&#x60; attributes specifies for which IP address the record is set. For IPv4 addresses this must be the exact address of the [Floating IP](#floating-ips). For IPv6 addresses this must be a single address within the &#x60;/64&#x60; subnet of the [Floating IP](#floating-ips).  The &#x60;dns_ptr&#x60; attribute specifies the hostname used for the IP address.  For IPv6 [Floating IPs](#floating-ips) up to 100 entries can be created.  (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeReverseDnsRecordsForFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IChangeReverseDnsRecordsForFloatingIpApiResponse> ChangeReverseDnsRecordsForFloatingIpAsync(long id, Option<DnsPtr> body = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeReverseDnsRecordsForFloatingIp(body);

                FormatChangeReverseDnsRecordsForFloatingIp(ref id, ref body);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}/actions/change_dns_ptr"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}/actions/change_dns_ptr");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (body.IsSet)
                        httpRequestMessageLocalVar.Content = (body.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(body.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeReverseDnsRecordsForFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeReverseDnsRecordsForFloatingIpApiResponse>();

                        ChangeReverseDnsRecordsForFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}/actions/change_dns_ptr", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeReverseDnsRecordsForFloatingIpDefaultImplementation(apiResponseLocalVar, id, body);

                        Events.ExecuteOnChangeReverseDnsRecordsForFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeReverseDnsRecordsForFloatingIpDefaultImplementation(e, "/floating_ips/{id}/actions/change_dns_ptr", uriBuilderLocalVar.Path, id, body);
                Events.ExecuteOnErrorChangeReverseDnsRecordsForFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeReverseDnsRecordsForFloatingIpApiResponse"/>
        /// </summary>
        public partial class ChangeReverseDnsRecordsForFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeReverseDnsRecordsForFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeReverseDnsRecordsForFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeReverseDnsRecordsForFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeReverseDnsRecordsForFloatingIpApiResponse(ILogger<ChangeReverseDnsRecordsForFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeReverseDnsRecordsForFloatingIpResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeReverseDnsRecordsForFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeReverseDnsRecordsForFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateFloatingIp(Option<CreateFloatingIpRequest> createFloatingIpRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createFloatingIpRequest"></param>
        /// <returns></returns>
        private void ValidateCreateFloatingIp(Option<CreateFloatingIpRequest> createFloatingIpRequest)
        {
            if (createFloatingIpRequest.IsSet && createFloatingIpRequest.Value == null)
                throw new ArgumentNullException(nameof(createFloatingIpRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createFloatingIpRequest"></param>
        private void AfterCreateFloatingIpDefaultImplementation(ICreateFloatingIpApiResponse apiResponseLocalVar, Option<CreateFloatingIpRequest> createFloatingIpRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, createFloatingIpRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createFloatingIpRequest"></param>
        partial void AfterCreateFloatingIp(ref bool suppressDefaultLog, ICreateFloatingIpApiResponse apiResponseLocalVar, Option<CreateFloatingIpRequest> createFloatingIpRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createFloatingIpRequest"></param>
        private void OnErrorCreateFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateFloatingIpRequest> createFloatingIpRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createFloatingIpRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createFloatingIpRequest"></param>
        partial void OnErrorCreateFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateFloatingIpRequest> createFloatingIpRequest);

        /// <summary>
        /// Create a Floating IP Create a [Floating IP](#floating-ips).  Provide the &#x60;server&#x60; attribute to assign the [Floating IP](#floating-ips) to that server or provide a &#x60;home_location&#x60; to locate the [Floating IP](#floating-ips) at. Note that the [Floating IP](#floating-ips) can be assigned to a [Server](#servers) in any [Location](#locations) later on. For optimal routing it is advised to use the [Floating IP](#floating-ips) in the same [Location](#locations) it was created in. 
        /// </summary>
        /// <param name="createFloatingIpRequest">The &#x60;type&#x60; argument is required while &#x60;home_location&#x60; and &#x60;server&#x60; are mutually exclusive. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateFloatingIpApiResponse"/>&gt;</returns>
        public async Task<ICreateFloatingIpApiResponse?> CreateFloatingIpOrDefaultAsync(Option<CreateFloatingIpRequest> createFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateFloatingIpAsync(createFloatingIpRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Floating IP Create a [Floating IP](#floating-ips).  Provide the &#x60;server&#x60; attribute to assign the [Floating IP](#floating-ips) to that server or provide a &#x60;home_location&#x60; to locate the [Floating IP](#floating-ips) at. Note that the [Floating IP](#floating-ips) can be assigned to a [Server](#servers) in any [Location](#locations) later on. For optimal routing it is advised to use the [Floating IP](#floating-ips) in the same [Location](#locations) it was created in. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createFloatingIpRequest">The &#x60;type&#x60; argument is required while &#x60;home_location&#x60; and &#x60;server&#x60; are mutually exclusive. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateFloatingIpApiResponse"/>&gt;</returns>
        public async Task<ICreateFloatingIpApiResponse> CreateFloatingIpAsync(Option<CreateFloatingIpRequest> createFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateFloatingIp(createFloatingIpRequest);

                FormatCreateFloatingIp(createFloatingIpRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips");

                    if (createFloatingIpRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (createFloatingIpRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createFloatingIpRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateFloatingIpApiResponse>();

                        CreateFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateFloatingIpDefaultImplementation(apiResponseLocalVar, createFloatingIpRequest);

                        Events.ExecuteOnCreateFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateFloatingIpDefaultImplementation(e, "/floating_ips", uriBuilderLocalVar.Path, createFloatingIpRequest);
                Events.ExecuteOnErrorCreateFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateFloatingIpApiResponse"/>
        /// </summary>
        public partial class CreateFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, ICreateFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateFloatingIpApiResponse(ILogger<CreateFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.CreateFloatingIpResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.CreateFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.CreateFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteFloatingIp(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteFloatingIpDefaultImplementation(IDeleteFloatingIpApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteFloatingIp(ref bool suppressDefaultLog, IDeleteFloatingIpApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Delete a Floating IP Deletes a [Floating IP](#floating-ips).  If the IP is assigned to a resource it will be unassigned. 
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IDeleteFloatingIpApiResponse?> DeleteFloatingIpOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteFloatingIpAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a Floating IP Deletes a [Floating IP](#floating-ips).  If the IP is assigned to a resource it will be unassigned. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IDeleteFloatingIpApiResponse> DeleteFloatingIpAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteFloatingIp(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteFloatingIpApiResponse>();

                        DeleteFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteFloatingIpDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteFloatingIpDefaultImplementation(e, "/floating_ips/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteFloatingIpApiResponse"/>
        /// </summary>
        public partial class DeleteFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IDeleteFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteFloatingIpApiResponse(ILogger<DeleteFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetActionForFloatingIp(ref long id, ref long actionId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void AfterGetActionForFloatingIpDefaultImplementation(IGetActionForFloatingIpApiResponse apiResponseLocalVar, long id, long actionId)
        {
            bool suppressDefaultLog = false;
            AfterGetActionForFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id, actionId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void AfterGetActionForFloatingIp(ref bool suppressDefaultLog, IGetActionForFloatingIpApiResponse apiResponseLocalVar, long id, long actionId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void OnErrorGetActionForFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetActionForFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, actionId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void OnErrorGetActionForFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId);

        /// <summary>
        /// Get an Action for a Floating IP Returns a specific [Action](#actions) for a [Floating IP](#floating-ips).
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IGetActionForFloatingIpApiResponse?> GetActionForFloatingIpOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetActionForFloatingIpAsync(id, actionId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action for a Floating IP Returns a specific [Action](#actions) for a [Floating IP](#floating-ips).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IGetActionForFloatingIpApiResponse> GetActionForFloatingIpAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetActionForFloatingIp(ref id, ref actionId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}/actions/{action_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}/actions/{action_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baction_id%7D", Uri.EscapeDataString(actionId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetActionForFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetActionForFloatingIpApiResponse>();

                        GetActionForFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}/actions/{action_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetActionForFloatingIpDefaultImplementation(apiResponseLocalVar, id, actionId);

                        Events.ExecuteOnGetActionForFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetActionForFloatingIpDefaultImplementation(e, "/floating_ips/{id}/actions/{action_id}", uriBuilderLocalVar.Path, id, actionId);
                Events.ExecuteOnErrorGetActionForFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetActionForFloatingIpApiResponse"/>
        /// </summary>
        public partial class GetActionForFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetActionForFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetActionForFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetActionForFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetActionForFloatingIpApiResponse(ILogger<GetActionForFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionForFloatingIpResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionForFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionForFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFloatingIp(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetFloatingIpDefaultImplementation(IGetFloatingIpApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetFloatingIp(ref bool suppressDefaultLog, IGetFloatingIpApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get a Floating IP Returns a single [Floating IP](#floating-ips).
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IGetFloatingIpApiResponse?> GetFloatingIpOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFloatingIpAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a Floating IP Returns a single [Floating IP](#floating-ips).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IGetFloatingIpApiResponse> GetFloatingIpAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetFloatingIp(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFloatingIpApiResponse>();

                        GetFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetFloatingIpDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFloatingIpDefaultImplementation(e, "/floating_ips/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFloatingIpApiResponse"/>
        /// </summary>
        public partial class GetFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFloatingIpApiResponse(ILogger<GetFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetFloatingIpResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFloatingIpAction(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetFloatingIpActionDefaultImplementation(IGetFloatingIpActionApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetFloatingIpAction(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetFloatingIpAction(ref bool suppressDefaultLog, IGetFloatingIpActionApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetFloatingIpActionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFloatingIpAction(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetFloatingIpAction(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get an Action Returns a single [Action](#actions).
        /// </summary>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpActionApiResponse"/>&gt;</returns>
        public async Task<IGetFloatingIpActionApiResponse?> GetFloatingIpActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFloatingIpActionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action Returns a single [Action](#actions).
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFloatingIpActionApiResponse"/>&gt;</returns>
        public async Task<IGetFloatingIpActionApiResponse> GetFloatingIpActionAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetFloatingIpAction(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/actions/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/actions/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetFloatingIpActionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFloatingIpActionApiResponse>();

                        GetFloatingIpActionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/actions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetFloatingIpActionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetFloatingIpAction(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFloatingIpActionDefaultImplementation(e, "/floating_ips/actions/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetFloatingIpAction(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFloatingIpActionApiResponse"/>
        /// </summary>
        public partial class GetFloatingIpActionApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetFloatingIpActionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFloatingIpActionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFloatingIpActionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFloatingIpActionApiResponse(ILogger<GetFloatingIpActionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListActionsForFloatingIp(ref long id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListActionsForFloatingIp(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListActionsForFloatingIpDefaultImplementation(IListActionsForFloatingIpApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListActionsForFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListActionsForFloatingIp(ref bool suppressDefaultLog, IListActionsForFloatingIpApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListActionsForFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListActionsForFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListActionsForFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions for a Floating IP Lists [Actions](#actions) for a [Floating IP](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IListActionsForFloatingIpApiResponse?> ListActionsForFloatingIpOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListActionsForFloatingIpAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions for a Floating IP Lists [Actions](#actions) for a [Floating IP](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IListActionsForFloatingIpApiResponse> ListActionsForFloatingIpAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListActionsForFloatingIp(sort, status);

                FormatListActionsForFloatingIp(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}/actions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListActionsForFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListActionsForFloatingIpApiResponse>();

                        ListActionsForFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListActionsForFloatingIpDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListActionsForFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListActionsForFloatingIpDefaultImplementation(e, "/floating_ips/{id}/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListActionsForFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListActionsForFloatingIpApiResponse"/>
        /// </summary>
        public partial class ListActionsForFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IListActionsForFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListActionsForFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListActionsForFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListActionsForFloatingIpApiResponse(ILogger<ListActionsForFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsForFloatingIpResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsForFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsForFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListFloatingIpActions(ref Option<long> id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListFloatingIpActions(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListFloatingIpActionsDefaultImplementation(IListFloatingIpActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListFloatingIpActions(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListFloatingIpActions(ref bool suppressDefaultLog, IListFloatingIpActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListFloatingIpActionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListFloatingIpActions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListFloatingIpActions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions Lists multiple [Actions](#actions).  Use the provided URI parameters to modify the result. 
        /// </summary>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpActionsApiResponse"/>&gt;</returns>
        public async Task<IListFloatingIpActionsApiResponse?> ListFloatingIpActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListFloatingIpActionsAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions Lists multiple [Actions](#actions).  Use the provided URI parameters to modify the result. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpActionsApiResponse"/>&gt;</returns>
        public async Task<IListFloatingIpActionsApiResponse> ListFloatingIpActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListFloatingIpActions(sort, status);

                FormatListFloatingIpActions(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/actions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListFloatingIpActionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListFloatingIpActionsApiResponse>();

                        ListFloatingIpActionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListFloatingIpActionsDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListFloatingIpActions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListFloatingIpActionsDefaultImplementation(e, "/floating_ips/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListFloatingIpActions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListFloatingIpActionsApiResponse"/>
        /// </summary>
        public partial class ListFloatingIpActionsApiResponse : Hetzner.Cloud.Client.ApiResponse, IListFloatingIpActionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListFloatingIpActionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListFloatingIpActionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListFloatingIpActionsApiResponse(ILogger<ListFloatingIpActionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListFloatingIps(ref Option<string> name, ref Option<string> labelSelector, ref Option<string> sort, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <returns></returns>
        private void ValidateListFloatingIps(Option<string> name, Option<string> labelSelector, Option<string> sort)
        {
            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (labelSelector.IsSet && labelSelector.Value == null)
                throw new ArgumentNullException(nameof(labelSelector));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListFloatingIpsDefaultImplementation(IListFloatingIpsApiResponse apiResponseLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListFloatingIps(ref suppressDefaultLog, apiResponseLocalVar, name, labelSelector, sort, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListFloatingIps(ref bool suppressDefaultLog, IListFloatingIpsApiResponse apiResponseLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListFloatingIpsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListFloatingIps(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, name, labelSelector, sort, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="sort"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListFloatingIps(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> name, Option<string> labelSelector, Option<string> sort, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Floating IPs List multiple [Floating IPs](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </summary>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpsApiResponse"/>&gt;</returns>
        public async Task<IListFloatingIpsApiResponse?> ListFloatingIpsOrDefaultAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListFloatingIpsAsync(name, labelSelector, sort, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Floating IPs List multiple [Floating IPs](#floating-ips).  Use the provided URI parameters to modify the result. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListFloatingIpsApiResponse"/>&gt;</returns>
        public async Task<IListFloatingIpsApiResponse> ListFloatingIpsAsync(Option<string> name = default, Option<string> labelSelector = default, Option<string> sort = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListFloatingIps(name, labelSelector, sort);

                FormatListFloatingIps(ref name, ref labelSelector, ref sort, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (labelSelector.IsSet)
                        parseQueryStringLocalVar["label_selector"] = ClientUtils.ParameterToString(labelSelector.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListFloatingIpsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListFloatingIpsApiResponse>();

                        ListFloatingIpsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListFloatingIpsDefaultImplementation(apiResponseLocalVar, name, labelSelector, sort, page, perPage);

                        Events.ExecuteOnListFloatingIps(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListFloatingIpsDefaultImplementation(e, "/floating_ips", uriBuilderLocalVar.Path, name, labelSelector, sort, page, perPage);
                Events.ExecuteOnErrorListFloatingIps(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListFloatingIpsApiResponse"/>
        /// </summary>
        public partial class ListFloatingIpsApiResponse : Hetzner.Cloud.Client.ApiResponse, IListFloatingIpsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListFloatingIpsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListFloatingIpsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListFloatingIpsApiResponse(ILogger<ListFloatingIpsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListFloatingIpsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListFloatingIpsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListFloatingIpsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReplaceFloatingIp(ref long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="replaceFloatingIpRequest"></param>
        /// <returns></returns>
        private void ValidateReplaceFloatingIp(Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest)
        {
            if (replaceFloatingIpRequest.IsSet && replaceFloatingIpRequest.Value == null)
                throw new ArgumentNullException(nameof(replaceFloatingIpRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceFloatingIpRequest"></param>
        private void AfterReplaceFloatingIpDefaultImplementation(IReplaceFloatingIpApiResponse apiResponseLocalVar, long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest)
        {
            bool suppressDefaultLog = false;
            AfterReplaceFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id, replaceFloatingIpRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceFloatingIpRequest"></param>
        partial void AfterReplaceFloatingIp(ref bool suppressDefaultLog, IReplaceFloatingIpApiResponse apiResponseLocalVar, long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceFloatingIpRequest"></param>
        private void OnErrorReplaceFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorReplaceFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, replaceFloatingIpRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceFloatingIpRequest"></param>
        partial void OnErrorReplaceFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest);

        /// <summary>
        /// Update a Floating IP Update the description or [Labels](#labels) of a [Floating IP](#floating-ips). Note that when updating [Labels](#labels), the [Floating IPs](#floating-ips) current set of [Labels](#labels) will be replaced with the [Labels](#labels) provided with the request. So, for example, if you want to add a new [Label](#labels), you have to provide all existing [Labels](#labels) plus the new [Label](#labels) in the request body.
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="replaceFloatingIpRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IReplaceFloatingIpApiResponse?> ReplaceFloatingIpOrDefaultAsync(long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReplaceFloatingIpAsync(id, replaceFloatingIpRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update a Floating IP Update the description or [Labels](#labels) of a [Floating IP](#floating-ips). Note that when updating [Labels](#labels), the [Floating IPs](#floating-ips) current set of [Labels](#labels) will be replaced with the [Labels](#labels) provided with the request. So, for example, if you want to add a new [Label](#labels), you have to provide all existing [Labels](#labels) plus the new [Label](#labels) in the request body.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="replaceFloatingIpRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IReplaceFloatingIpApiResponse> ReplaceFloatingIpAsync(long id, Option<ReplaceFloatingIpRequest> replaceFloatingIpRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateReplaceFloatingIp(replaceFloatingIpRequest);

                FormatReplaceFloatingIp(ref id, replaceFloatingIpRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (replaceFloatingIpRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (replaceFloatingIpRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(replaceFloatingIpRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ReplaceFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReplaceFloatingIpApiResponse>();

                        ReplaceFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReplaceFloatingIpDefaultImplementation(apiResponseLocalVar, id, replaceFloatingIpRequest);

                        Events.ExecuteOnReplaceFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReplaceFloatingIpDefaultImplementation(e, "/floating_ips/{id}", uriBuilderLocalVar.Path, id, replaceFloatingIpRequest);
                Events.ExecuteOnErrorReplaceFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReplaceFloatingIpApiResponse"/>
        /// </summary>
        public partial class ReplaceFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IReplaceFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReplaceFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReplaceFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReplaceFloatingIpApiResponse(ILogger<ReplaceFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ReplaceFloatingIpResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ReplaceFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ReplaceFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUnassignFloatingIp(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterUnassignFloatingIpDefaultImplementation(IUnassignFloatingIpApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterUnassignFloatingIp(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterUnassignFloatingIp(ref bool suppressDefaultLog, IUnassignFloatingIpApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorUnassignFloatingIpDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUnassignFloatingIp(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorUnassignFloatingIp(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Unassign a Floating IP Unassigns a [Floating IP](#floating-ips).  Results in the IP being unreachable. Can be assigned to another resource again. 
        /// </summary>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnassignFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IUnassignFloatingIpApiResponse?> UnassignFloatingIpOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UnassignFloatingIpAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Unassign a Floating IP Unassigns a [Floating IP](#floating-ips).  Results in the IP being unreachable. Can be assigned to another resource again. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Floating IP.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUnassignFloatingIpApiResponse"/>&gt;</returns>
        public async Task<IUnassignFloatingIpApiResponse> UnassignFloatingIpAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatUnassignFloatingIp(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/floating_ips/{id}/actions/unassign"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/floating_ips/{id}/actions/unassign");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<UnassignFloatingIpApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UnassignFloatingIpApiResponse>();

                        UnassignFloatingIpApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/floating_ips/{id}/actions/unassign", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterUnassignFloatingIpDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnUnassignFloatingIp(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUnassignFloatingIpDefaultImplementation(e, "/floating_ips/{id}/actions/unassign", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorUnassignFloatingIp(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UnassignFloatingIpApiResponse"/>
        /// </summary>
        public partial class UnassignFloatingIpApiResponse : Hetzner.Cloud.Client.ApiResponse, IUnassignFloatingIpApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UnassignFloatingIpApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UnassignFloatingIpApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UnassignFloatingIpApiResponse(ILogger<UnassignFloatingIpApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.UnassignFloatingIpResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.UnassignFloatingIpResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.UnassignFloatingIpResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
