// <auto-generated>
/*
 * Hetzner Cloud API
 *
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: 0.22.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using Hetzner.Cloud.Client;
using Hetzner.Cloud.Model;
using System.Diagnostics.CodeAnalysis;

namespace Hetzner.Cloud.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IVolumesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        VolumesApiEvents Events { get; }

        /// <summary>
        /// Attach Volume to a Server
        /// </summary>
        /// <remarks>
        /// Attaches a Volume to a Server. Works only if the Server is in the same Location as the Volume.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="attachVolumeToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachVolumeToServerApiResponse"/>&gt;</returns>
        Task<IAttachVolumeToServerApiResponse> AttachVolumeToServerAsync(long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Attach Volume to a Server
        /// </summary>
        /// <remarks>
        /// Attaches a Volume to a Server. Works only if the Server is in the same Location as the Volume.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="attachVolumeToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachVolumeToServerApiResponse"/>?&gt;</returns>
        Task<IAttachVolumeToServerApiResponse?> AttachVolumeToServerOrDefaultAsync(long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change Volume Protection
        /// </summary>
        /// <remarks>
        /// Changes the protection configuration of a Volume.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="changeVolumeProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeVolumeProtectionApiResponse"/>&gt;</returns>
        Task<IChangeVolumeProtectionApiResponse> ChangeVolumeProtectionAsync(long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Change Volume Protection
        /// </summary>
        /// <remarks>
        /// Changes the protection configuration of a Volume.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="changeVolumeProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeVolumeProtectionApiResponse"/>?&gt;</returns>
        Task<IChangeVolumeProtectionApiResponse?> ChangeVolumeProtectionOrDefaultAsync(long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Volume
        /// </summary>
        /// <remarks>
        /// Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the &#x60;location&#x60; key instead of &#x60;server&#x60;. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.  Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the &#x60;next_actions&#x60; key in the response is an array which contains a single &#x60;attach_volume&#x60; action.  The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).  A volume’s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.  #### Call specific error codes  | Code                                | Description                                         | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;no_space_left_in_location&#x60;         | There is no volume space left in the given location | 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVolumeApiResponse"/>&gt;</returns>
        Task<ICreateVolumeApiResponse> CreateVolumeAsync(Option<CreateVolumeRequest> createVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Create a Volume
        /// </summary>
        /// <remarks>
        /// Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the &#x60;location&#x60; key instead of &#x60;server&#x60;. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.  Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the &#x60;next_actions&#x60; key in the response is an array which contains a single &#x60;attach_volume&#x60; action.  The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).  A volume’s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.  #### Call specific error codes  | Code                                | Description                                         | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;no_space_left_in_location&#x60;         | There is no volume space left in the given location | 
        /// </remarks>
        /// <param name="createVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVolumeApiResponse"/>?&gt;</returns>
        Task<ICreateVolumeApiResponse?> CreateVolumeOrDefaultAsync(Option<CreateVolumeRequest> createVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Volume
        /// </summary>
        /// <remarks>
        /// Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVolumeApiResponse"/>&gt;</returns>
        Task<IDeleteVolumeApiResponse> DeleteVolumeAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Delete a Volume
        /// </summary>
        /// <remarks>
        /// Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVolumeApiResponse"/>?&gt;</returns>
        Task<IDeleteVolumeApiResponse?> DeleteVolumeOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detach Volume
        /// </summary>
        /// <remarks>
        /// Detaches a Volume from the Server it’s attached to. You may attach it to a Server again at a later time.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachVolumeApiResponse"/>&gt;</returns>
        Task<IDetachVolumeApiResponse> DetachVolumeAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Detach Volume
        /// </summary>
        /// <remarks>
        /// Detaches a Volume from the Server it’s attached to. You may attach it to a Server again at a later time.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachVolumeApiResponse"/>?&gt;</returns>
        Task<IDetachVolumeApiResponse?> DetachVolumeOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Volume
        /// </summary>
        /// <remarks>
        /// Returns a specific Action for a Volume.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForVolumeApiResponse"/>&gt;</returns>
        Task<IGetActionForVolumeApiResponse> GetActionForVolumeAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action for a Volume
        /// </summary>
        /// <remarks>
        /// Returns a specific Action for a Volume.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForVolumeApiResponse"/>?&gt;</returns>
        Task<IGetActionForVolumeApiResponse?> GetActionForVolumeOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Volume
        /// </summary>
        /// <remarks>
        /// Gets a specific Volume object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeApiResponse"/>&gt;</returns>
        Task<IGetVolumeApiResponse> GetVolumeAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get a Volume
        /// </summary>
        /// <remarks>
        /// Gets a specific Volume object.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeApiResponse"/>?&gt;</returns>
        Task<IGetVolumeApiResponse?> GetVolumeOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeActionApiResponse"/>&gt;</returns>
        Task<IGetVolumeActionApiResponse> GetVolumeActionAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get an Action
        /// </summary>
        /// <remarks>
        /// Returns a specific Action object.
        /// </remarks>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeActionApiResponse"/>?&gt;</returns>
        Task<IGetVolumeActionApiResponse?> GetVolumeActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Volume
        /// </summary>
        /// <remarks>
        /// Returns all Action objects for a Volume. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForVolumeApiResponse"/>&gt;</returns>
        Task<IListActionsForVolumeApiResponse> ListActionsForVolumeAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions for a Volume
        /// </summary>
        /// <remarks>
        /// Returns all Action objects for a Volume. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForVolumeApiResponse"/>?&gt;</returns>
        Task<IListActionsForVolumeApiResponse?> ListActionsForVolumeOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumeActionsApiResponse"/>&gt;</returns>
        Task<IListVolumeActionsApiResponse> ListVolumeActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Actions
        /// </summary>
        /// <remarks>
        /// Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </remarks>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumeActionsApiResponse"/>?&gt;</returns>
        Task<IListVolumeActionsApiResponse?> ListVolumeActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Volumes
        /// </summary>
        /// <remarks>
        /// Gets all existing Volumes that you have available.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Can be used multiple times. The response will only contain Volumes matching the status. (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumesApiResponse"/>&gt;</returns>
        Task<IListVolumesApiResponse> ListVolumesAsync(Option<string> status = default, Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Get all Volumes
        /// </summary>
        /// <remarks>
        /// Gets all existing Volumes that you have available.
        /// </remarks>
        /// <param name="status">Can be used multiple times. The response will only contain Volumes matching the status. (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumesApiResponse"/>?&gt;</returns>
        Task<IListVolumesApiResponse?> ListVolumesOrDefaultAsync(Option<string> status = default, Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Volume
        /// </summary>
        /// <remarks>
        /// Updates the Volume properties.  Note that when updating labels, the volume’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="replaceVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceVolumeApiResponse"/>&gt;</returns>
        Task<IReplaceVolumeApiResponse> ReplaceVolumeAsync(long id, Option<ReplaceVolumeRequest> replaceVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Update a Volume
        /// </summary>
        /// <remarks>
        /// Updates the Volume properties.  Note that when updating labels, the volume’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. 
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="replaceVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceVolumeApiResponse"/>?&gt;</returns>
        Task<IReplaceVolumeApiResponse?> ReplaceVolumeOrDefaultAsync(long id, Option<ReplaceVolumeRequest> replaceVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Resize Volume
        /// </summary>
        /// <remarks>
        /// Changes the size of a Volume. Note that downsizing a Volume is not possible.
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="resizeVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResizeVolumeApiResponse"/>&gt;</returns>
        Task<IResizeVolumeApiResponse> ResizeVolumeAsync(long id, Option<ResizeVolumeRequest> resizeVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Resize Volume
        /// </summary>
        /// <remarks>
        /// Changes the size of a Volume. Note that downsizing a Volume is not possible.
        /// </remarks>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="resizeVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResizeVolumeApiResponse"/>?&gt;</returns>
        Task<IResizeVolumeApiResponse?> ResizeVolumeOrDefaultAsync(long id, Option<ResizeVolumeRequest> resizeVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAttachVolumeToServerApiResponse"/>
    /// </summary>
    public interface IAttachVolumeToServerApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.AttachVolumeToServerResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IChangeVolumeProtectionApiResponse"/>
    /// </summary>
    public interface IChangeVolumeProtectionApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ChangeVolumeProtectionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="ICreateVolumeApiResponse"/>
    /// </summary>
    public interface ICreateVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.CreateVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IDeleteVolumeApiResponse"/>
    /// </summary>
    public interface IDeleteVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 204 NoContent
        /// </summary>
        /// <returns></returns>
        bool IsNoContent { get; }
    }

    /// <summary>
    /// The <see cref="IDetachVolumeApiResponse"/>
    /// </summary>
    public interface IDetachVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.DetachVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// The <see cref="IGetActionForVolumeApiResponse"/>
    /// </summary>
    public interface IGetActionForVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionForVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetVolumeApiResponse"/>
    /// </summary>
    public interface IGetVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IGetVolumeActionApiResponse"/>
    /// </summary>
    public interface IGetVolumeActionApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.GetActionResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListActionsForVolumeApiResponse"/>
    /// </summary>
    public interface IListActionsForVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsForVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListVolumeActionsApiResponse"/>
    /// </summary>
    public interface IListVolumeActionsApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListActionsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IListVolumesApiResponse"/>
    /// </summary>
    public interface IListVolumesApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ListVolumesResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IReplaceVolumeApiResponse"/>
    /// </summary>
    public interface IReplaceVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, IOk<Hetzner.Cloud.Model.ReplaceVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }
    }

    /// <summary>
    /// The <see cref="IResizeVolumeApiResponse"/>
    /// </summary>
    public interface IResizeVolumeApiResponse : Hetzner.Cloud.Client.IApiResponse, ICreated<Hetzner.Cloud.Model.ResizeVolumeResponse?>
    {
        /// <summary>
        /// Returns true if the response is 201 Created
        /// </summary>
        /// <returns></returns>
        bool IsCreated { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class VolumesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAttachVolumeToServer;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAttachVolumeToServer;

        internal void ExecuteOnAttachVolumeToServer(VolumesApi.AttachVolumeToServerApiResponse apiResponse)
        {
            OnAttachVolumeToServer?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAttachVolumeToServer(Exception exception)
        {
            OnErrorAttachVolumeToServer?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnChangeVolumeProtection;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorChangeVolumeProtection;

        internal void ExecuteOnChangeVolumeProtection(VolumesApi.ChangeVolumeProtectionApiResponse apiResponse)
        {
            OnChangeVolumeProtection?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorChangeVolumeProtection(Exception exception)
        {
            OnErrorChangeVolumeProtection?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnCreateVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorCreateVolume;

        internal void ExecuteOnCreateVolume(VolumesApi.CreateVolumeApiResponse apiResponse)
        {
            OnCreateVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorCreateVolume(Exception exception)
        {
            OnErrorCreateVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDeleteVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDeleteVolume;

        internal void ExecuteOnDeleteVolume(VolumesApi.DeleteVolumeApiResponse apiResponse)
        {
            OnDeleteVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDeleteVolume(Exception exception)
        {
            OnErrorDeleteVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnDetachVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorDetachVolume;

        internal void ExecuteOnDetachVolume(VolumesApi.DetachVolumeApiResponse apiResponse)
        {
            OnDetachVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorDetachVolume(Exception exception)
        {
            OnErrorDetachVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetActionForVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetActionForVolume;

        internal void ExecuteOnGetActionForVolume(VolumesApi.GetActionForVolumeApiResponse apiResponse)
        {
            OnGetActionForVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetActionForVolume(Exception exception)
        {
            OnErrorGetActionForVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetVolume;

        internal void ExecuteOnGetVolume(VolumesApi.GetVolumeApiResponse apiResponse)
        {
            OnGetVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetVolume(Exception exception)
        {
            OnErrorGetVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetVolumeAction;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetVolumeAction;

        internal void ExecuteOnGetVolumeAction(VolumesApi.GetVolumeActionApiResponse apiResponse)
        {
            OnGetVolumeAction?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetVolumeAction(Exception exception)
        {
            OnErrorGetVolumeAction?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListActionsForVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListActionsForVolume;

        internal void ExecuteOnListActionsForVolume(VolumesApi.ListActionsForVolumeApiResponse apiResponse)
        {
            OnListActionsForVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListActionsForVolume(Exception exception)
        {
            OnErrorListActionsForVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListVolumeActions;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListVolumeActions;

        internal void ExecuteOnListVolumeActions(VolumesApi.ListVolumeActionsApiResponse apiResponse)
        {
            OnListVolumeActions?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListVolumeActions(Exception exception)
        {
            OnErrorListVolumeActions?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnListVolumes;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorListVolumes;

        internal void ExecuteOnListVolumes(VolumesApi.ListVolumesApiResponse apiResponse)
        {
            OnListVolumes?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorListVolumes(Exception exception)
        {
            OnErrorListVolumes?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnReplaceVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorReplaceVolume;

        internal void ExecuteOnReplaceVolume(VolumesApi.ReplaceVolumeApiResponse apiResponse)
        {
            OnReplaceVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorReplaceVolume(Exception exception)
        {
            OnErrorReplaceVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnResizeVolume;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorResizeVolume;

        internal void ExecuteOnResizeVolume(VolumesApi.ResizeVolumeApiResponse apiResponse)
        {
            OnResizeVolume?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorResizeVolume(Exception exception)
        {
            OnErrorResizeVolume?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class VolumesApi : IVolumesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<VolumesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public VolumesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BearerToken"/>
        /// </summary>
        public TokenProvider<BearerToken> BearerTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="VolumesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public VolumesApi(ILogger<VolumesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, VolumesApiEvents volumesApiEvents,
            TokenProvider<BearerToken> bearerTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<VolumesApi>();
            HttpClient = httpClient;
            Events = volumesApiEvents;
            BearerTokenProvider = bearerTokenProvider;
        }

        partial void FormatAttachVolumeToServer(ref long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="attachVolumeToServerRequest"></param>
        /// <returns></returns>
        private void ValidateAttachVolumeToServer(Option<AttachVolumeToServerRequest> attachVolumeToServerRequest)
        {
            if (attachVolumeToServerRequest.IsSet && attachVolumeToServerRequest.Value == null)
                throw new ArgumentNullException(nameof(attachVolumeToServerRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachVolumeToServerRequest"></param>
        private void AfterAttachVolumeToServerDefaultImplementation(IAttachVolumeToServerApiResponse apiResponseLocalVar, long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest)
        {
            bool suppressDefaultLog = false;
            AfterAttachVolumeToServer(ref suppressDefaultLog, apiResponseLocalVar, id, attachVolumeToServerRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachVolumeToServerRequest"></param>
        partial void AfterAttachVolumeToServer(ref bool suppressDefaultLog, IAttachVolumeToServerApiResponse apiResponseLocalVar, long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachVolumeToServerRequest"></param>
        private void OnErrorAttachVolumeToServerDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAttachVolumeToServer(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, attachVolumeToServerRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="attachVolumeToServerRequest"></param>
        partial void OnErrorAttachVolumeToServer(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest);

        /// <summary>
        /// Attach Volume to a Server Attaches a Volume to a Server. Works only if the Server is in the same Location as the Volume.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="attachVolumeToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachVolumeToServerApiResponse"/>&gt;</returns>
        public async Task<IAttachVolumeToServerApiResponse?> AttachVolumeToServerOrDefaultAsync(long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AttachVolumeToServerAsync(id, attachVolumeToServerRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Attach Volume to a Server Attaches a Volume to a Server. Works only if the Server is in the same Location as the Volume.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="attachVolumeToServerRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAttachVolumeToServerApiResponse"/>&gt;</returns>
        public async Task<IAttachVolumeToServerApiResponse> AttachVolumeToServerAsync(long id, Option<AttachVolumeToServerRequest> attachVolumeToServerRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateAttachVolumeToServer(attachVolumeToServerRequest);

                FormatAttachVolumeToServer(ref id, attachVolumeToServerRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}/actions/attach"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}/actions/attach");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (attachVolumeToServerRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (attachVolumeToServerRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(attachVolumeToServerRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<AttachVolumeToServerApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AttachVolumeToServerApiResponse>();

                        AttachVolumeToServerApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}/actions/attach", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterAttachVolumeToServerDefaultImplementation(apiResponseLocalVar, id, attachVolumeToServerRequest);

                        Events.ExecuteOnAttachVolumeToServer(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAttachVolumeToServerDefaultImplementation(e, "/volumes/{id}/actions/attach", uriBuilderLocalVar.Path, id, attachVolumeToServerRequest);
                Events.ExecuteOnErrorAttachVolumeToServer(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AttachVolumeToServerApiResponse"/>
        /// </summary>
        public partial class AttachVolumeToServerApiResponse : Hetzner.Cloud.Client.ApiResponse, IAttachVolumeToServerApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AttachVolumeToServerApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AttachVolumeToServerApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AttachVolumeToServerApiResponse(ILogger<AttachVolumeToServerApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.AttachVolumeToServerResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.AttachVolumeToServerResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.AttachVolumeToServerResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatChangeVolumeProtection(ref long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="changeVolumeProtectionRequest"></param>
        /// <returns></returns>
        private void ValidateChangeVolumeProtection(Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest)
        {
            if (changeVolumeProtectionRequest.IsSet && changeVolumeProtectionRequest.Value == null)
                throw new ArgumentNullException(nameof(changeVolumeProtectionRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeVolumeProtectionRequest"></param>
        private void AfterChangeVolumeProtectionDefaultImplementation(IChangeVolumeProtectionApiResponse apiResponseLocalVar, long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest)
        {
            bool suppressDefaultLog = false;
            AfterChangeVolumeProtection(ref suppressDefaultLog, apiResponseLocalVar, id, changeVolumeProtectionRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeVolumeProtectionRequest"></param>
        partial void AfterChangeVolumeProtection(ref bool suppressDefaultLog, IChangeVolumeProtectionApiResponse apiResponseLocalVar, long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeVolumeProtectionRequest"></param>
        private void OnErrorChangeVolumeProtectionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorChangeVolumeProtection(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, changeVolumeProtectionRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="changeVolumeProtectionRequest"></param>
        partial void OnErrorChangeVolumeProtection(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest);

        /// <summary>
        /// Change Volume Protection Changes the protection configuration of a Volume.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="changeVolumeProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeVolumeProtectionApiResponse"/>&gt;</returns>
        public async Task<IChangeVolumeProtectionApiResponse?> ChangeVolumeProtectionOrDefaultAsync(long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ChangeVolumeProtectionAsync(id, changeVolumeProtectionRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Change Volume Protection Changes the protection configuration of a Volume.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="changeVolumeProtectionRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IChangeVolumeProtectionApiResponse"/>&gt;</returns>
        public async Task<IChangeVolumeProtectionApiResponse> ChangeVolumeProtectionAsync(long id, Option<ChangeVolumeProtectionRequest> changeVolumeProtectionRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateChangeVolumeProtection(changeVolumeProtectionRequest);

                FormatChangeVolumeProtection(ref id, changeVolumeProtectionRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}/actions/change_protection"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}/actions/change_protection");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (changeVolumeProtectionRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (changeVolumeProtectionRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(changeVolumeProtectionRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ChangeVolumeProtectionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ChangeVolumeProtectionApiResponse>();

                        ChangeVolumeProtectionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}/actions/change_protection", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterChangeVolumeProtectionDefaultImplementation(apiResponseLocalVar, id, changeVolumeProtectionRequest);

                        Events.ExecuteOnChangeVolumeProtection(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorChangeVolumeProtectionDefaultImplementation(e, "/volumes/{id}/actions/change_protection", uriBuilderLocalVar.Path, id, changeVolumeProtectionRequest);
                Events.ExecuteOnErrorChangeVolumeProtection(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ChangeVolumeProtectionApiResponse"/>
        /// </summary>
        public partial class ChangeVolumeProtectionApiResponse : Hetzner.Cloud.Client.ApiResponse, IChangeVolumeProtectionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ChangeVolumeProtectionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ChangeVolumeProtectionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ChangeVolumeProtectionApiResponse(ILogger<ChangeVolumeProtectionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ChangeVolumeProtectionResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ChangeVolumeProtectionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ChangeVolumeProtectionResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatCreateVolume(Option<CreateVolumeRequest> createVolumeRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="createVolumeRequest"></param>
        /// <returns></returns>
        private void ValidateCreateVolume(Option<CreateVolumeRequest> createVolumeRequest)
        {
            if (createVolumeRequest.IsSet && createVolumeRequest.Value == null)
                throw new ArgumentNullException(nameof(createVolumeRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createVolumeRequest"></param>
        private void AfterCreateVolumeDefaultImplementation(ICreateVolumeApiResponse apiResponseLocalVar, Option<CreateVolumeRequest> createVolumeRequest)
        {
            bool suppressDefaultLog = false;
            AfterCreateVolume(ref suppressDefaultLog, apiResponseLocalVar, createVolumeRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="createVolumeRequest"></param>
        partial void AfterCreateVolume(ref bool suppressDefaultLog, ICreateVolumeApiResponse apiResponseLocalVar, Option<CreateVolumeRequest> createVolumeRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createVolumeRequest"></param>
        private void OnErrorCreateVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateVolumeRequest> createVolumeRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorCreateVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, createVolumeRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="createVolumeRequest"></param>
        partial void OnErrorCreateVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<CreateVolumeRequest> createVolumeRequest);

        /// <summary>
        /// Create a Volume Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the &#x60;location&#x60; key instead of &#x60;server&#x60;. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.  Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the &#x60;next_actions&#x60; key in the response is an array which contains a single &#x60;attach_volume&#x60; action.  The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).  A volume’s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.  #### Call specific error codes  | Code                                | Description                                         | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;no_space_left_in_location&#x60;         | There is no volume space left in the given location | 
        /// </summary>
        /// <param name="createVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVolumeApiResponse"/>&gt;</returns>
        public async Task<ICreateVolumeApiResponse?> CreateVolumeOrDefaultAsync(Option<CreateVolumeRequest> createVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await CreateVolumeAsync(createVolumeRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Create a Volume Creates a new Volume attached to a Server. If you want to create a Volume that is not attached to a Server, you need to provide the &#x60;location&#x60; key instead of &#x60;server&#x60;. This can be either the ID or the name of the Location this Volume will be created in. Note that a Volume can be attached to a Server only in the same Location as the Volume itself.  Specifying the Server during Volume creation will automatically attach the Volume to that Server after it has been initialized. In that case, the &#x60;next_actions&#x60; key in the response is an array which contains a single &#x60;attach_volume&#x60; action.  The minimum Volume size is 10GB and the maximum size is 10TB (10240GB).  A volume’s name can consist of alphanumeric characters, dashes, underscores, and dots, but has to start and end with an alphanumeric character. The total length is limited to 64 characters. Volume names must be unique per Project.  #### Call specific error codes  | Code                                | Description                                         | |- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --|- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --| | &#x60;no_space_left_in_location&#x60;         | There is no volume space left in the given location | 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="createVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ICreateVolumeApiResponse"/>&gt;</returns>
        public async Task<ICreateVolumeApiResponse> CreateVolumeAsync(Option<CreateVolumeRequest> createVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateCreateVolume(createVolumeRequest);

                FormatCreateVolume(createVolumeRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes");

                    if (createVolumeRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (createVolumeRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(createVolumeRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<CreateVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<CreateVolumeApiResponse>();

                        CreateVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterCreateVolumeDefaultImplementation(apiResponseLocalVar, createVolumeRequest);

                        Events.ExecuteOnCreateVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorCreateVolumeDefaultImplementation(e, "/volumes", uriBuilderLocalVar.Path, createVolumeRequest);
                Events.ExecuteOnErrorCreateVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="CreateVolumeApiResponse"/>
        /// </summary>
        public partial class CreateVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, ICreateVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<CreateVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="CreateVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public CreateVolumeApiResponse(ILogger<CreateVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.CreateVolumeResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.CreateVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.CreateVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDeleteVolume(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDeleteVolumeDefaultImplementation(IDeleteVolumeApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDeleteVolume(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDeleteVolume(ref bool suppressDefaultLog, IDeleteVolumeApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDeleteVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDeleteVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDeleteVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Delete a Volume Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVolumeApiResponse"/>&gt;</returns>
        public async Task<IDeleteVolumeApiResponse?> DeleteVolumeOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DeleteVolumeAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Delete a Volume Deletes a volume. All Volume data is irreversibly destroyed. The Volume must not be attached to a Server and it must not have delete protection enabled.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDeleteVolumeApiResponse"/>&gt;</returns>
        public async Task<IDeleteVolumeApiResponse> DeleteVolumeAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDeleteVolume(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    httpRequestMessageLocalVar.Method = HttpMethod.Delete;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DeleteVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DeleteVolumeApiResponse>();

                        DeleteVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDeleteVolumeDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDeleteVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDeleteVolumeDefaultImplementation(e, "/volumes/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDeleteVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DeleteVolumeApiResponse"/>
        /// </summary>
        public partial class DeleteVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IDeleteVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DeleteVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DeleteVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DeleteVolumeApiResponse(ILogger<DeleteVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 204 NoContent
            /// </summary>
            /// <returns></returns>
            public bool IsNoContent => 204 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatDetachVolume(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterDetachVolumeDefaultImplementation(IDetachVolumeApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterDetachVolume(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterDetachVolume(ref bool suppressDefaultLog, IDetachVolumeApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorDetachVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorDetachVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorDetachVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Detach Volume Detaches a Volume from the Server it’s attached to. You may attach it to a Server again at a later time.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachVolumeApiResponse"/>&gt;</returns>
        public async Task<IDetachVolumeApiResponse?> DetachVolumeOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await DetachVolumeAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Detach Volume Detaches a Volume from the Server it’s attached to. You may attach it to a Server again at a later time.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IDetachVolumeApiResponse"/>&gt;</returns>
        public async Task<IDetachVolumeApiResponse> DetachVolumeAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatDetachVolume(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}/actions/detach"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}/actions/detach");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<DetachVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<DetachVolumeApiResponse>();

                        DetachVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}/actions/detach", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterDetachVolumeDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnDetachVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorDetachVolumeDefaultImplementation(e, "/volumes/{id}/actions/detach", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorDetachVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="DetachVolumeApiResponse"/>
        /// </summary>
        public partial class DetachVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IDetachVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<DetachVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="DetachVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public DetachVolumeApiResponse(ILogger<DetachVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.DetachVolumeResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.DetachVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.DetachVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetActionForVolume(ref long id, ref long actionId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void AfterGetActionForVolumeDefaultImplementation(IGetActionForVolumeApiResponse apiResponseLocalVar, long id, long actionId)
        {
            bool suppressDefaultLog = false;
            AfterGetActionForVolume(ref suppressDefaultLog, apiResponseLocalVar, id, actionId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void AfterGetActionForVolume(ref bool suppressDefaultLog, IGetActionForVolumeApiResponse apiResponseLocalVar, long id, long actionId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        private void OnErrorGetActionForVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetActionForVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, actionId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="actionId"></param>
        partial void OnErrorGetActionForVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, long actionId);

        /// <summary>
        /// Get an Action for a Volume Returns a specific Action for a Volume.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForVolumeApiResponse"/>&gt;</returns>
        public async Task<IGetActionForVolumeApiResponse?> GetActionForVolumeOrDefaultAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetActionForVolumeAsync(id, actionId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action for a Volume Returns a specific Action for a Volume.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="actionId">ID of the Action.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetActionForVolumeApiResponse"/>&gt;</returns>
        public async Task<IGetActionForVolumeApiResponse> GetActionForVolumeAsync(long id, long actionId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetActionForVolume(ref id, ref actionId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}/actions/{action_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}/actions/{action_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baction_id%7D", Uri.EscapeDataString(actionId.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetActionForVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetActionForVolumeApiResponse>();

                        GetActionForVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}/actions/{action_id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetActionForVolumeDefaultImplementation(apiResponseLocalVar, id, actionId);

                        Events.ExecuteOnGetActionForVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetActionForVolumeDefaultImplementation(e, "/volumes/{id}/actions/{action_id}", uriBuilderLocalVar.Path, id, actionId);
                Events.ExecuteOnErrorGetActionForVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetActionForVolumeApiResponse"/>
        /// </summary>
        public partial class GetActionForVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetActionForVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetActionForVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetActionForVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetActionForVolumeApiResponse(ILogger<GetActionForVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionForVolumeResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionForVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionForVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetVolume(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetVolumeDefaultImplementation(IGetVolumeApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetVolume(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetVolume(ref bool suppressDefaultLog, IGetVolumeApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get a Volume Gets a specific Volume object.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeApiResponse"/>&gt;</returns>
        public async Task<IGetVolumeApiResponse?> GetVolumeOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetVolumeAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get a Volume Gets a specific Volume object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeApiResponse"/>&gt;</returns>
        public async Task<IGetVolumeApiResponse> GetVolumeAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetVolume(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetVolumeApiResponse>();

                        GetVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetVolumeDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetVolumeDefaultImplementation(e, "/volumes/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetVolumeApiResponse"/>
        /// </summary>
        public partial class GetVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetVolumeApiResponse(ILogger<GetVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetVolumeResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetVolumeAction(ref long id);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        private void AfterGetVolumeActionDefaultImplementation(IGetVolumeActionApiResponse apiResponseLocalVar, long id)
        {
            bool suppressDefaultLog = false;
            AfterGetVolumeAction(ref suppressDefaultLog, apiResponseLocalVar, id);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        partial void AfterGetVolumeAction(ref bool suppressDefaultLog, IGetVolumeActionApiResponse apiResponseLocalVar, long id);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        private void OnErrorGetVolumeActionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetVolumeAction(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        partial void OnErrorGetVolumeAction(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id);

        /// <summary>
        /// Get an Action Returns a specific Action object.
        /// </summary>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeActionApiResponse"/>&gt;</returns>
        public async Task<IGetVolumeActionApiResponse?> GetVolumeActionOrDefaultAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetVolumeActionAsync(id, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get an Action Returns a specific Action object.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Action</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetVolumeActionApiResponse"/>&gt;</returns>
        public async Task<IGetVolumeActionApiResponse> GetVolumeActionAsync(long id, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatGetVolumeAction(ref id);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/actions/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/actions/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<GetVolumeActionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetVolumeActionApiResponse>();

                        GetVolumeActionApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/actions/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterGetVolumeActionDefaultImplementation(apiResponseLocalVar, id);

                        Events.ExecuteOnGetVolumeAction(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetVolumeActionDefaultImplementation(e, "/volumes/actions/{id}", uriBuilderLocalVar.Path, id);
                Events.ExecuteOnErrorGetVolumeAction(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetVolumeActionApiResponse"/>
        /// </summary>
        public partial class GetVolumeActionApiResponse : Hetzner.Cloud.Client.ApiResponse, IGetVolumeActionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetVolumeActionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetVolumeActionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetVolumeActionApiResponse(ILogger<GetVolumeActionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.GetActionResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.GetActionResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.GetActionResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListActionsForVolume(ref long id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListActionsForVolume(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListActionsForVolumeDefaultImplementation(IListActionsForVolumeApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListActionsForVolume(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListActionsForVolume(ref bool suppressDefaultLog, IListActionsForVolumeApiResponse apiResponseLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListActionsForVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListActionsForVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListActionsForVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions for a Volume Returns all Action objects for a Volume. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForVolumeApiResponse"/>&gt;</returns>
        public async Task<IListActionsForVolumeApiResponse?> ListActionsForVolumeOrDefaultAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListActionsForVolumeAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions for a Volume Returns all Action objects for a Volume. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListActionsForVolumeApiResponse"/>&gt;</returns>
        public async Task<IListActionsForVolumeApiResponse> ListActionsForVolumeAsync(long id, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListActionsForVolume(sort, status);

                FormatListActionsForVolume(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}/actions");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListActionsForVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListActionsForVolumeApiResponse>();

                        ListActionsForVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListActionsForVolumeDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListActionsForVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListActionsForVolumeDefaultImplementation(e, "/volumes/{id}/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListActionsForVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListActionsForVolumeApiResponse"/>
        /// </summary>
        public partial class ListActionsForVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IListActionsForVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListActionsForVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListActionsForVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListActionsForVolumeApiResponse(ILogger<ListActionsForVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsForVolumeResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsForVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsForVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListVolumeActions(ref Option<long> id, ref Option<string> sort, ref Option<string> status, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <returns></returns>
        private void ValidateListVolumeActions(Option<string> sort, Option<string> status)
        {
            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListVolumeActionsDefaultImplementation(IListVolumeActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListVolumeActions(ref suppressDefaultLog, apiResponseLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListVolumeActions(ref bool suppressDefaultLog, IListVolumeActionsApiResponse apiResponseLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListVolumeActionsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListVolumeActions(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, sort, status, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="sort"></param>
        /// <param name="status"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListVolumeActions(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long> id, Option<string> sort, Option<string> status, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Actions Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </summary>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumeActionsApiResponse"/>&gt;</returns>
        public async Task<IListVolumeActionsApiResponse?> ListVolumeActionsOrDefaultAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListVolumeActionsAsync(id, sort, status, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Actions Returns all Action objects. You can &#x60;sort&#x60; the results by using the sort URI parameter, and filter them with the &#x60;status&#x60; and &#x60;id&#x60; parameter.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs.  (optional)</param>
        /// <param name="sort">Sort actions by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="status">Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumeActionsApiResponse"/>&gt;</returns>
        public async Task<IListVolumeActionsApiResponse> ListVolumeActionsAsync(Option<long> id = default, Option<string> sort = default, Option<string> status = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListVolumeActions(sort, status);

                FormatListVolumeActions(ref id, ref sort, ref status, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/actions"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/actions");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (id.IsSet)
                        parseQueryStringLocalVar["id"] = ClientUtils.ParameterToString(id.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListVolumeActionsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListVolumeActionsApiResponse>();

                        ListVolumeActionsApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/actions", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListVolumeActionsDefaultImplementation(apiResponseLocalVar, id, sort, status, page, perPage);

                        Events.ExecuteOnListVolumeActions(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListVolumeActionsDefaultImplementation(e, "/volumes/actions", uriBuilderLocalVar.Path, id, sort, status, page, perPage);
                Events.ExecuteOnErrorListVolumeActions(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListVolumeActionsApiResponse"/>
        /// </summary>
        public partial class ListVolumeActionsApiResponse : Hetzner.Cloud.Client.ApiResponse, IListVolumeActionsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListVolumeActionsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListVolumeActionsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListVolumeActionsApiResponse(ILogger<ListVolumeActionsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListActionsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListActionsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListActionsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatListVolumes(ref Option<string> status, ref Option<string> sort, ref Option<string> name, ref Option<string> labelSelector, ref Option<long> page, ref Option<long> perPage);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="status"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <returns></returns>
        private void ValidateListVolumes(Option<string> status, Option<string> sort, Option<string> name, Option<string> labelSelector)
        {
            if (status.IsSet && status.Value == null)
                throw new ArgumentNullException(nameof(status));

            if (sort.IsSet && sort.Value == null)
                throw new ArgumentNullException(nameof(sort));

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name));

            if (labelSelector.IsSet && labelSelector.Value == null)
                throw new ArgumentNullException(nameof(labelSelector));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void AfterListVolumesDefaultImplementation(IListVolumesApiResponse apiResponseLocalVar, Option<string> status, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLog = false;
            AfterListVolumes(ref suppressDefaultLog, apiResponseLocalVar, status, sort, name, labelSelector, page, perPage);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void AfterListVolumes(ref bool suppressDefaultLog, IListVolumesApiResponse apiResponseLocalVar, Option<string> status, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        private void OnErrorListVolumesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> status, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<long> page, Option<long> perPage)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorListVolumes(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, status, sort, name, labelSelector, page, perPage);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="status"></param>
        /// <param name="sort"></param>
        /// <param name="name"></param>
        /// <param name="labelSelector"></param>
        /// <param name="page"></param>
        /// <param name="perPage"></param>
        partial void OnErrorListVolumes(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> status, Option<string> sort, Option<string> name, Option<string> labelSelector, Option<long> page, Option<long> perPage);

        /// <summary>
        /// Get all Volumes Gets all existing Volumes that you have available.
        /// </summary>
        /// <param name="status">Can be used multiple times. The response will only contain Volumes matching the status. (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumesApiResponse"/>&gt;</returns>
        public async Task<IListVolumesApiResponse?> ListVolumesOrDefaultAsync(Option<string> status = default, Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ListVolumesAsync(status, sort, name, labelSelector, page, perPage, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Get all Volumes Gets all existing Volumes that you have available.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="status">Can be used multiple times. The response will only contain Volumes matching the status. (optional)</param>
        /// <param name="sort">Sort resources by field and direction. Can be used multiple times. For more information, see \&quot;[Sorting](#sorting)\&quot;.  (optional)</param>
        /// <param name="name">Filter resources by their name. The response will only contain the resources matching the specified name.  (optional)</param>
        /// <param name="labelSelector">Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \&quot;[Label Selector](#label-selector)\&quot;.  (optional)</param>
        /// <param name="page">Page number to return. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 1)</param>
        /// <param name="perPage">Maximum number of entries returned per page. For more information, see \&quot;[Pagination](#pagination)\&quot;. (optional, default to 25)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IListVolumesApiResponse"/>&gt;</returns>
        public async Task<IListVolumesApiResponse> ListVolumesAsync(Option<string> status = default, Option<string> sort = default, Option<string> name = default, Option<string> labelSelector = default, Option<long> page = default, Option<long> perPage = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateListVolumes(status, sort, name, labelSelector);

                FormatListVolumes(ref status, ref sort, ref name, ref labelSelector, ref page, ref perPage);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (status.IsSet)
                        parseQueryStringLocalVar["status"] = ClientUtils.ParameterToString(status.Value);

                    if (sort.IsSet)
                        parseQueryStringLocalVar["sort"] = ClientUtils.ParameterToString(sort.Value);

                    if (name.IsSet)
                        parseQueryStringLocalVar["name"] = ClientUtils.ParameterToString(name.Value);

                    if (labelSelector.IsSet)
                        parseQueryStringLocalVar["label_selector"] = ClientUtils.ParameterToString(labelSelector.Value);

                    if (page.IsSet)
                        parseQueryStringLocalVar["page"] = ClientUtils.ParameterToString(page.Value);

                    if (perPage.IsSet)
                        parseQueryStringLocalVar["per_page"] = ClientUtils.ParameterToString(perPage.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ListVolumesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ListVolumesApiResponse>();

                        ListVolumesApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterListVolumesDefaultImplementation(apiResponseLocalVar, status, sort, name, labelSelector, page, perPage);

                        Events.ExecuteOnListVolumes(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorListVolumesDefaultImplementation(e, "/volumes", uriBuilderLocalVar.Path, status, sort, name, labelSelector, page, perPage);
                Events.ExecuteOnErrorListVolumes(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ListVolumesApiResponse"/>
        /// </summary>
        public partial class ListVolumesApiResponse : Hetzner.Cloud.Client.ApiResponse, IListVolumesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ListVolumesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ListVolumesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ListVolumesApiResponse(ILogger<ListVolumesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ListVolumesResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ListVolumesResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ListVolumesResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatReplaceVolume(ref long id, Option<ReplaceVolumeRequest> replaceVolumeRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="replaceVolumeRequest"></param>
        /// <returns></returns>
        private void ValidateReplaceVolume(Option<ReplaceVolumeRequest> replaceVolumeRequest)
        {
            if (replaceVolumeRequest.IsSet && replaceVolumeRequest.Value == null)
                throw new ArgumentNullException(nameof(replaceVolumeRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceVolumeRequest"></param>
        private void AfterReplaceVolumeDefaultImplementation(IReplaceVolumeApiResponse apiResponseLocalVar, long id, Option<ReplaceVolumeRequest> replaceVolumeRequest)
        {
            bool suppressDefaultLog = false;
            AfterReplaceVolume(ref suppressDefaultLog, apiResponseLocalVar, id, replaceVolumeRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceVolumeRequest"></param>
        partial void AfterReplaceVolume(ref bool suppressDefaultLog, IReplaceVolumeApiResponse apiResponseLocalVar, long id, Option<ReplaceVolumeRequest> replaceVolumeRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceVolumeRequest"></param>
        private void OnErrorReplaceVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceVolumeRequest> replaceVolumeRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorReplaceVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, replaceVolumeRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="replaceVolumeRequest"></param>
        partial void OnErrorReplaceVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ReplaceVolumeRequest> replaceVolumeRequest);

        /// <summary>
        /// Update a Volume Updates the Volume properties.  Note that when updating labels, the volume’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. 
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="replaceVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceVolumeApiResponse"/>&gt;</returns>
        public async Task<IReplaceVolumeApiResponse?> ReplaceVolumeOrDefaultAsync(long id, Option<ReplaceVolumeRequest> replaceVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ReplaceVolumeAsync(id, replaceVolumeRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Update a Volume Updates the Volume properties.  Note that when updating labels, the volume’s current set of labels will be replaced with the labels provided in the request body. So, for example, if you want to add a new label, you have to provide all existing labels plus the new label in the request body. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="replaceVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IReplaceVolumeApiResponse"/>&gt;</returns>
        public async Task<IReplaceVolumeApiResponse> ReplaceVolumeAsync(long id, Option<ReplaceVolumeRequest> replaceVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateReplaceVolume(replaceVolumeRequest);

                FormatReplaceVolume(ref id, replaceVolumeRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (replaceVolumeRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (replaceVolumeRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(replaceVolumeRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Put;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ReplaceVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ReplaceVolumeApiResponse>();

                        ReplaceVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterReplaceVolumeDefaultImplementation(apiResponseLocalVar, id, replaceVolumeRequest);

                        Events.ExecuteOnReplaceVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorReplaceVolumeDefaultImplementation(e, "/volumes/{id}", uriBuilderLocalVar.Path, id, replaceVolumeRequest);
                Events.ExecuteOnErrorReplaceVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ReplaceVolumeApiResponse"/>
        /// </summary>
        public partial class ReplaceVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IReplaceVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ReplaceVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ReplaceVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ReplaceVolumeApiResponse(ILogger<ReplaceVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ReplaceVolumeResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ReplaceVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Hetzner.Cloud.Model.ReplaceVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatResizeVolume(ref long id, Option<ResizeVolumeRequest> resizeVolumeRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="resizeVolumeRequest"></param>
        /// <returns></returns>
        private void ValidateResizeVolume(Option<ResizeVolumeRequest> resizeVolumeRequest)
        {
            if (resizeVolumeRequest.IsSet && resizeVolumeRequest.Value == null)
                throw new ArgumentNullException(nameof(resizeVolumeRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="resizeVolumeRequest"></param>
        private void AfterResizeVolumeDefaultImplementation(IResizeVolumeApiResponse apiResponseLocalVar, long id, Option<ResizeVolumeRequest> resizeVolumeRequest)
        {
            bool suppressDefaultLog = false;
            AfterResizeVolume(ref suppressDefaultLog, apiResponseLocalVar, id, resizeVolumeRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="resizeVolumeRequest"></param>
        partial void AfterResizeVolume(ref bool suppressDefaultLog, IResizeVolumeApiResponse apiResponseLocalVar, long id, Option<ResizeVolumeRequest> resizeVolumeRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="resizeVolumeRequest"></param>
        private void OnErrorResizeVolumeDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ResizeVolumeRequest> resizeVolumeRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorResizeVolume(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, id, resizeVolumeRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="id"></param>
        /// <param name="resizeVolumeRequest"></param>
        partial void OnErrorResizeVolume(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long id, Option<ResizeVolumeRequest> resizeVolumeRequest);

        /// <summary>
        /// Resize Volume Changes the size of a Volume. Note that downsizing a Volume is not possible.
        /// </summary>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="resizeVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResizeVolumeApiResponse"/>&gt;</returns>
        public async Task<IResizeVolumeApiResponse?> ResizeVolumeOrDefaultAsync(long id, Option<ResizeVolumeRequest> resizeVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ResizeVolumeAsync(id, resizeVolumeRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Resize Volume Changes the size of a Volume. Note that downsizing a Volume is not possible.
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">ID of the Volume.</param>
        /// <param name="resizeVolumeRequest"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IResizeVolumeApiResponse"/>&gt;</returns>
        public async Task<IResizeVolumeApiResponse> ResizeVolumeAsync(long id, Option<ResizeVolumeRequest> resizeVolumeRequest = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateResizeVolume(resizeVolumeRequest);

                FormatResizeVolume(ref id, resizeVolumeRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/volumes/{id}/actions/resize"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/volumes/{id}/actions/resize");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bid%7D", Uri.EscapeDataString(id.ToString()));

                    if (resizeVolumeRequest.IsSet)
                        httpRequestMessageLocalVar.Content = (resizeVolumeRequest.Value as object) is System.IO.Stream stream
                            ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                            : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(resizeVolumeRequest.Value, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BearerToken bearerTokenLocalVar1 = (BearerToken) await BearerTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(bearerTokenLocalVar1);

                    bearerTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);

                        ILogger<ResizeVolumeApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ResizeVolumeApiResponse>();

                        ResizeVolumeApiResponse apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/volumes/{id}/actions/resize", requestedAtLocalVar, _jsonSerializerOptions);

                        AfterResizeVolumeDefaultImplementation(apiResponseLocalVar, id, resizeVolumeRequest);

                        Events.ExecuteOnResizeVolume(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorResizeVolumeDefaultImplementation(e, "/volumes/{id}/actions/resize", uriBuilderLocalVar.Path, id, resizeVolumeRequest);
                Events.ExecuteOnErrorResizeVolume(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ResizeVolumeApiResponse"/>
        /// </summary>
        public partial class ResizeVolumeApiResponse : Hetzner.Cloud.Client.ApiResponse, IResizeVolumeApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ResizeVolumeApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ResizeVolumeApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ResizeVolumeApiResponse(ILogger<ResizeVolumeApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public bool IsCreated => 201 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 201 Created
            /// </summary>
            /// <returns></returns>
            public Hetzner.Cloud.Model.ResizeVolumeResponse? Created()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsCreated
                    ? System.Text.Json.JsonSerializer.Deserialize<Hetzner.Cloud.Model.ResizeVolumeResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 201 Created and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryCreated([NotNullWhen(true)]out Hetzner.Cloud.Model.ResizeVolumeResponse? result)
            {
                result = null;

                try
                {
                    result = Created();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)201);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
